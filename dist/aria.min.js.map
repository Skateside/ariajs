{"version":3,"sources":["aria.js"],"names":["globalVariable","ARIA","factories","Object","create","translate","defineProperty","configurable","enumerable","writable","value","identity","x","arrayFrom","Array","from","arrayLike","map","context","undefined","prototype","call","normalise","attribute","normal","String","toLowerCase","replace","normaliseDescriptor","get","set","normaliser","defineProperties","normalize","noop","fnTest","test","addClassMethods","name","method","parent","this","keys","forEach","key","returnValue","hasSuper","temp","$super","apply","arguments","createClass","Base","proto","Class","init","addMethod","addMethods","constructor","getFactory","runFactory","factory","ReferenceError","slice","addAlias","source","aliases","normalSource","isArray","alias","normalAlias","setAttribute","element","getAttribute","hasAttribute","removeAttribute","getById","id","document","getElementById","counter","defaultIdentifyPrefix","identify","prefix","isNode","Node","setTabindex","tabindex","Math","floor","isNaN","removeTabindex","addToTabOrder","removeFromTabOrder","Property","that","toString","setTokens","tokens","setPattern","pattern","isValidToken","token","isValid","length","indexOf","interpret","has","remove","trim","Integer","interpretted","NaN","Number","parseFloat","State","UndefinedState","Tristate","lists","WeakMap","makeIterator","instance","valueMaker","index","list","next","iteratorValue","done","DOMEx","type","message","code","DOMException","Error","List","val","join","string","split","values","unwanted","toArray","filter","item","add","contains","glue","argument","push","splice","oldToken","newToken","isReplaced","oldItem","newItem","handler","entries","window","Symbol","iterator","Reference","ReferenceList","Boolean","Element","manipulationFlags","preloadAttributes","readAttributes","observeAttributes","hasOwnProperty","attributes","observer","MutationObserver","mutations","mutation","attributeName","suffix","oldValue","setTimeout","observe","attributeOldValue","disconnectAttributes","disconnect","AriaProperty","AriaList","addNodeProperty","settings","descriptor","getter","entry","property","Constructor","roles","role"],"mappings":"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","sourcesContent":["/*! ariajs - v0.1.0 - MIT license - https://github.com/Skateside/ariajs - 2018-10-26 */\n(function (globalVariable) {\n    \"use strict\";\n\n/**\n * @namespace\n */\nvar ARIA = {\n\n    /**\n     * Collection of factories for creating WAI-ARIA libraries.\n     * @type {Object}\n     */\n    factories: Object.create(null),\n\n    /**\n     * Map of all mis-spellings and aliases.\n     * @type {Object}\n     */\n    translate: Object.create(null)\n\n};\n\n/**\n * The version of the library.\n *\n * @memberof ARIA\n * @type {String}\n * @constant\n * @name VERSION\n */\nObject.defineProperty(ARIA, \"VERSION\", {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value: \"0.1.0\"\n});\n\n/**\n * A function that returns the given variable unchanged.\n *\n * @private\n * @param   {?} x\n *          Variable to return.\n * @return  {?}\n *          Unmodified original variable.\n */\nvar identity = function (x) {\n    return x;\n};\n\n/**\n * Simple fall-back for Array.from.\n *\n * @private\n * @param   {Object} arrayLike\n *          Array-like structure.\n * @param   {Function} [map=identity]\n *          Optional function to convert the values.\n * @param   {?} [context]\n *          Optional context for the map function.\n * @return  {Array}\n *          Array made from the iven array-like structure.\n */\nvar arrayFrom = Array.from || function (arrayLike, map, context) {\n\n    if (map === undefined) {\n        map = identity;\n    }\n\n    return Array.prototype.map.call(arrayLike, map, context);\n\n};\n\n/**\n * Normalises an attribute name so that it is in lowercase and always starts\n * with \"aria-\". This function has the alias of {@link ARIA.normalize} and\n * changing one will update the other.\n *\n * @memberof ARIA\n * @param    {String} attribute\n *           Attribute to normalise.\n * @return   {String}\n *           Normalised attribute.\n *\n * @example\n * ARIA.normalise(\"aria-busy\"); // -> \"aria-busy\"\n * ARIA.normalise(\"busy\"); // -> \"aria-busy\"\n * ARIA.normalise(\"  busy  \"); // -> \"aria-busy\"\n * ARIA.normalise(\"BUSY\"); // -> \"aria-busy\"\n */\nvar normalise = function (attribute) {\n\n    var string = String(attribute)\n        .toLowerCase()\n        .replace(/^\\s*(?:aria\\-)?|\\s*$/g, \"\");\n    var normal = \"aria-\" + string;\n\n    return ARIA.translate[normal] || normal;\n\n};\n\nvar normaliseDescriptor = {\n\n    configurable: false,\n    enumerable: true,\n\n    get: function () {\n        return normalise;\n    },\n\n    set: function (normaliser) {\n        normalise = normaliser;\n    }\n\n};\n\nObject.defineProperties(ARIA, {\n\n    normalise: normaliseDescriptor,\n\n    /**\n     * An alias of {@link ARIA.normalise}.\n     *\n     * @memberof ARIA\n     * @function\n     */\n    normalize: normaliseDescriptor\n\n});\n\n/**\n * A function that does nothing.\n *\n * @private\n */\nvar noop = function () {\n    return;\n};\n\nvar fnTest = (\n    (/return/).test(noop)\n    ? (/[.'\"]\\$super\\b/)\n    : (/.*/)\n);\n\n/**\n * Adds one or more methods to the class.\n *\n * @memberof Class\n * @name     addMethod\n * @static\n * @param    {Object|String} name\n *           Either the name of the method to add or an object of names to\n *           methods.\n * @param    {Function} [method]\n *           Method to add to the class.\n */\nfunction addClassMethods(name, method) {\n\n    var parent = this.parent;\n\n    if (typeof name === \"object\") {\n\n        Object.keys(name).forEach(function (key) {\n            addClassMethods.call(this, key, name[key]);\n        }, this);\n\n    } else {\n\n        this.prototype[name] = (\n            (\n                typeof method === \"function\"\n                && typeof parent[name] === \"function\"\n                && fnTest.test(method)\n            )\n            ? function () {\n\n                var hasSuper = \"$super\" in this;\n                var temp = this.$super;\n                var returnValue = null;\n\n                this.$super = parent[name];\n                returnValue = method.apply(this, arguments);\n\n                if (hasSuper) {\n                    this.$super = temp;\n                } else {\n                    delete this.$super;\n                }\n\n                return returnValue;\n\n            }\n            : method\n        );\n\n    }\n\n}\n\n/**\n * Creates a Class.\n *\n * @param  {Class} [Base]\n *         Optional parent class.\n * @param  {Object} proto\n *         Methods to add to the created Class' prototype.\n * @return {Class}\n *         Class created.\n */\nARIA.createClass = function (Base, proto) {\n\n    function Class() {\n        return this.init.apply(this, arguments);\n    }\n\n    if (!proto) {\n\n        proto = Base;\n        Base = Object;\n\n    }\n\n    Class.addMethod = addClassMethods;\n\n    /**\n     * Alias of {@link Class.addMethod}\n     */\n    Class.addMethods = addClassMethods;\n\n    /**\n     * Reference to the prototype of the Class' super-class.\n     * @type {Object}\n     */\n    Class.parent = Base.prototype;\n\n    Class.prototype = Object.create(Base.prototype);\n    addClassMethods.call(Class, proto);\n\n    Class.prototype.constructor = Class;\n\n    if (typeof Class.prototype.init !== \"function\") {\n        Class.prototype.init = noop;\n    }\n\n    return Class;\n\n};\n\n/**\n * Gets the factory from {@link ARIA.factories} that matches either the given\n * attribute or the normalised version (see {@link ARIA.normalise}).\n *\n * @param  {String} attribute\n *         Attribute whose factory should be returned.\n * @return {Function}\n *         Factory for creating the attribute.\n */\nARIA.getFactory = function (attribute) {\n\n    return (\n        ARIA.factories[attribute]\n        || ARIA.factories[ARIA.normalise(attribute)]\n    );\n\n};\n\n/**\n * Executes the factory for the given attribute, passing in given parameters.\n * See {@link ARIA.getFactory}.\n *\n * @param  {String} attribute\n *         Attribute whose factory should be executed.\n * @param  {...?} [arguments]\n *         Optional parameters to pass to the factory.\n * @return {?}\n *         Result of executing the factory.\n * @throws {ReferenceError}\n *         There must be a factory for the given attribute.\n */\nARIA.runFactory = function (attribute) {\n\n    var factory = ARIA.getFactory(attribute);\n\n    if (!factory) {\n        throw new ReferenceError(attribute + \" is not a recognised factory\");\n    }\n\n    return factory.apply(undefined, Array.prototype.slice.call(arguments, 1));\n\n};\n\n/**\n * Creates an alias of WAI-ARIA attributes.\n *\n * @param  {String} source\n *         Source attribute for the alias.\n * @param  {Array.<String>|String} aliases\n *         Either a single alias or an array of aliases.\n * @throws {ReferenceError}\n *         The source attribute must have a related factory.\n */\nARIA.addAlias = function (source, aliases) {\n\n    var normalSource = ARIA.normalise(source).slice(5);\n\n    if (!Array.isArray(aliases)) {\n        aliases = [aliases];\n    }\n\n    if (!ARIA.getFactory(normalSource)) {\n\n        throw new ReferenceError(\n            \"ARIA.factories.\"\n            + normalSource\n            + \" does not exist\"\n        );\n\n    }\n\n    aliases.forEach(function (alias) {\n\n        var normalAlias = ARIA.normalise(alias).slice(5);\n\n        ARIA.translate[normalAlias] = normalSource;\n        ARIA.factories[normalAlias] = ARIA.factories[normalSource];\n\n    });\n\n};\n\n/**\n * A wrapper for setting an attribute on an element. This allows the method to\n * be easily replaced for virtual DOMs.\n *\n * @param {Element} element\n *        Element whose attribute should be set.\n * @param {String} name\n *        Name of the attribute to set.\n * @param {String} value\n *        Value of the attribute.\n */\nARIA.setAttribute = function (element, name, value) {\n    element.setAttribute(name, value);\n};\n\n/**\n * A wrapper for getting an attribute of an element. THis allows the method to\n * be easily replaced for virtual DOMs.\n *\n * @param  {Element} element\n *         Element whose attribute should be retrieved.\n * @param  {String} name\n *         Name of the attribute to retrieve.\n * @return {String|null}\n *         The value of the attribute or null if that attribute does not exist.\n */\nARIA.getAttribute = function (element, name) {\n    return element.getAttribute(name);\n};\n\n/**\n * A wrapper for checking for an attribute on an element. THis allows the method\n * to be easily replaced for virtual DOMs.\n *\n * @param  {Element} element\n *         Element whose attribute should be checked.\n * @param  {String} name\n *         Name of the attribute to check.\n * @return {Boolean}\n *         true if the element has the given attribute, false otherwise.\n */\nARIA.hasAttribute = function (element, name) {\n    return element.hasAttribute(name);\n};\n\n/**\n * A wrapper for removing an attribute from an element. THis allows the method\n * to be easily replaced for virtual DOMs.\n *\n * @param {Element} element\n *        Element whose attribute should be removed.\n * @param {String} name\n *        Name of the attribute to remove.\n */\nARIA.removeAttribute = function (element, name) {\n    element.removeAttribute(name);\n};\n\n/**\n * Gets an element by the given ID. If the element cannot be found, null is\n * returned. This function is just a wrapper for document.getElementById to\n * allow the library to be easily modified in case a virtual DOM is being used.\n *\n * @param  {String} id\n *         ID of the element to find.\n * @return {Element|null}\n *         Element with the given ID or null if the element cannot be found.\n */\nARIA.getById = function (id) {\n    return document.getElementById(id);\n};\n\nvar counter = 0;\n\n/**\n * The default prefix for {@link ARIA.identify}.\n * @type {String}\n */\nARIA.defaultIdentifyPrefix = \"anonymous-element-\";\n\n/**\n * Returns the ID of the given element. If the element does not have an ID, a\n * unique one is generated. THe Generated ID is the given prefix and an\n * incrementing counter.\n * Pro tip: The HTML specs state that element IDs should start with a letter.\n *\n * @param  {Element} element\n *         Element whose ID should be returned.\n * @param  {String} [prefix=ARIA.defaultIdentifyPrefix]\n *         Prefix for the generated ID.\n * @return {String}\n *         The ID of the element.\n */\nARIA.identify = function (element, prefix) {\n\n    var id = ARIA.getAttribute(element, \"id\");\n\n    if (prefix === undefined) {\n        prefix = ARIA.defaultIdentifyPrefix;\n    }\n\n    if (!id) {\n\n        do {\n\n            id = prefix + counter;\n            counter += 1;\n\n        } while (ARIA.getById(id));\n\n        ARIA.setAttribute(element, \"id\", id);\n\n    }\n\n    return id;\n\n};\n\n/**\n * Checks to see if the given value is a Node.\n *\n * @param  {?} value\n *         Value to test.\n * @return {Boolean}\n *         true if the given value is a Node, false otherwise.\n */\nARIA.isNode = function (value) {\n    return (value instanceof Node);\n};\n\n/**\n * Sets the tabindex of an element to the given value. THe value is validated to\n * ensure that it's valid - if it is not, no action is taken.\n *\n * @param {Element} element\n *        Element whose tabindex should be set.\n * @param {Number} value\n *        Value of the tab index to set.\n */\nARIA.setTabindex = function (element, value) {\n\n    var tabindex = (\n        value === -1 || (value >= 0 && value < 32767)\n        ? Math.floor(value)\n        : undefined\n    );\n\n    if (tabindex !== undefined && !isNaN(tabindex)) {\n        ARIA.setAttribute(element, \"tabindex\", tabindex);\n    }\n\n};\n\n/**\n * Helper function for removing the tabindex from an element.\n *\n * @param {Element} element\n *        Element whose tabindex should be removed.\n */\nARIA.removeTabindex = function (element) {\n    ARIA.removeAttribute(element, \"tabindex\");\n};\n\n/**\n * Adds the given element to the tab order by setting its tabindex to 0. If you\n * need more control over the value of the tab index, use\n * {@link ARIA.setTabindex}.\n *\n * @param {Element} element\n *        Element that should be added to the tab order.\n */\nARIA.addToTabOrder = function (element) {\n    ARIA.setTabindex(element, 0);\n};\n\n/**\n * Removed the given element from the tab order by setting its tabindex to -1.\n *\n * @param {Element} element\n *        Element that should be removed from the tab order.\n */\nARIA.removeFromTabOrder = function (element) {\n    ARIA.setTabindex(element, -1);\n};\n\n/**\n * Handles basic WAI-ARIA properties.\n *\n * @class ARIA.Property\n */\nARIA.Property = ARIA.createClass(/** @lends ARIA.Property.prototype */{\n\n    /**\n     * @constructs ARIA.Property\n     * @param      {Element} element\n     *             Element whose attribute should be handled.\n     * @param      {String} attribute\n     *             Name of the attribute to handle.\n     */\n    init: function (element, attribute) {\n\n        var that = this;\n\n        /**\n         * Element whose attribute is being handled.\n         * @type {Element}\n         */\n        that.element = element;\n\n        /**\n         * Attribute being handled.\n         * @type {String}\n         */\n        that.attribute = attribute;\n\n        // Things like ARIA.List work with interpretted values rather than just\n        // the attribute value. If the attribute already exists, pass the value\n        // to the set method to allow for that. As a bonus, this can filter out\n        // invalid attribute values.\n        if (that.hasAttribute()) {\n            that.set(that.getAttribute());\n        }\n\n        /**\n         * The value of the {@link ARIA.Property#attribute}.\n         *\n         * @memberof ARIA.Property\n         * @instance\n         * @name value\n         * @type {String}\n         */\n        Object.defineProperty(that, \"value\", {\n\n            get: function () {\n                return that.toString();\n            }\n\n        });\n\n    },\n\n    /**\n     * Sets the white-list of allowed tokens for this property.\n     *\n     * @param {Array.<String>} tokens\n     *        White-list of tokens.\n     */\n    setTokens: function (tokens) {\n\n        /**\n         * White-list of valid tokens.\n         * @type {Array.<String>}\n         */\n        this.tokens = arrayFrom(tokens);\n\n    },\n\n    /**\n     * Sets the pattern to work out if values are valid.\n     *\n     * @param {RegExp} pattern\n     *        Pattern for the values.\n     */\n    setPattern: function (pattern) {\n\n        /**\n         * Pattern that values have to match. Be aware that\n         * {@link ARIA.Property#tokens} will override this pattern even if they\n         * don't match.\n         * @type {RegExp}\n         */\n        this.pattern = pattern;\n\n    },\n\n    /**\n     * Checks to see if the given token is valid for this current property. This\n     * function checks against {@link ARIA.Property#tokens} and\n     * {@link ARIA.Property#pattern} if they're set.\n     *\n     * @param  {String} token\n     *         Token to check.\n     * @return {Boolean}\n     *         true if the token is valid, false otherwise.\n     */\n    isValidToken: function (token) {\n\n        var tokens = this.tokens;\n        var pattern = this.pattern;\n        var isValid = true;\n\n        if (tokens && tokens.length) {\n            isValid = tokens.indexOf(token) > -1;\n        } else if (pattern) {\n            isValid = pattern.test(token);\n        }\n\n        return isValid;\n\n    },\n\n    /**\n     * Interprets the given value so it can be set.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {String}\n     *         String based on the value.\n     */\n    interpret: function (value) {\n        return ARIA.Property.interpret(value);\n    },\n\n    /**\n     * Sets {@link ARIA.Property#attribute} to the given value, once\n     * interpretted (see {@link ARIA.Property#interpret}) and validated (see\n     * {@link ARIA.Property#isValidToken}).\n     *\n     * @param {?} value\n     *        Value to set.\n     */\n    set: function (value) {\n\n        var token = this.interpret(value);\n\n        if (token !== \"\" && this.isValidToken(token)) {\n            this.setAttribute(token);\n        } else if (token === \"\") {\n            this.removeAttribute();\n        }\n\n    },\n\n    /**\n     * Gets the value of {@link ARIA.Property#attribute} and interprets it\n     * (see {@link ARIA.Property#interpret}).\n     *\n     * @return {String}\n     *         Interpretted value of {@link ARIA.Property#attribute}.\n     */\n    get: function () {\n        return this.interpret(this.getAttribute());\n    },\n\n    /**\n     * Checks whether or not {@link ARIA.Property#attribute} is set on\n     * {@link ARIA.Property#element}.\n     *\n     * @return {Boolean}\n     *         true if the attribute is set, false otherwise.\n     */\n    has: function () {\n        return this.hasAttribute();\n    },\n\n    /**\n     * Removes {@link ARIA.Property#attribute} from\n     * {@link ARIA.Property#element}.\n     */\n    remove: function () {\n        this.removeAttribute();\n    },\n\n    /**\n     * Sets the value of {@link ARIA.Property#attribute}. This method bypasses\n     * the validation and interpretation processes of {@link ARIA.Property#set}.\n     * If value is empty (a falsy valid in JavaScript, but neither false nor 0)\n     * then the attribute is removed.\n     *\n     * @param {String} value\n     *        Value of the attribute to set.\n     */\n    setAttribute: function (value) {\n\n        if (ARIA.Property.interpret(value) !== \"\") {\n            ARIA.setAttribute(this.element, this.attribute, value);\n        } else {\n            this.removeAttribute();\n        }\n\n    },\n\n    /**\n     * Gets the value of {@link ARIA.Property#attribute}. THis bypasses the\n     * interpretation of {@link ARIA.Property#get}.\n     *\n     * @return {String|null}\n     *         Value of the attribute or null if the attribute is not set.\n     */\n    getAttribute: function () {\n        return ARIA.getAttribute(this.element, this.attribute);\n    },\n\n    /**\n     * Checks to see if {@link ARIA.Property#element} has\n     * {@link ARIA.Property#attribute}.\n     *\n     * @return {Boolean}\n     *         true if the attribute is set, false otherwise.\n     */\n    hasAttribute: function () {\n        return ARIA.hasAttribute(this.element, this.attribute);\n    },\n\n    /**\n     * Removes {@link ARIA.Property#attribute} from\n     * {@link ARIA.Property#element}.\n     */\n    removeAttribute: function () {\n        ARIA.removeAttribute(this.element, this.attribute);\n    },\n\n    /**\n     * Returns the value of {@link ARIA.Property#attribute} as a string. See\n     * {@link ARIA.Property#get}.\n     *\n     * @return {String}\n     *         Value of the attribute.\n     */\n    toString: function () {\n        return this.getAttribute() || \"\";\n    }\n\n});\n\n/**\n * Interprets the given value so it can be set. This is used to power\n * {@link ARIA.Property#interpret} while also being exposed so other functions\n * and classes can use it.\n *\n * @param  {?} value\n *         Value to interpret.\n * @return {String}\n *         String based on the value.\n */\nARIA.Property.interpret = function (value) {\n\n    return (\n        (value === null || value === undefined)\n        ? \"\"\n        : String(value).trim()\n    );\n\n};\n\n/**\n * Handles integer values.\n *\n * @class ARIA.Integer\n * @extends ARIA.Property\n */\nARIA.Integer = ARIA.createClass(ARIA.Property, {\n\n    /**\n     * @inheritDoc\n     */\n    init: function (element, attribute) {\n\n        this.$super(element, attribute);\n        this.setPattern(/^\\d+$/);\n\n    },\n\n    /**\n     * Interprets the value as an integer, discarding the decimal place. If the\n     * value can't be converted into a number, NaN is returned.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Number}\n     *         Integer value.\n     */\n    interpret: function (value) {\n\n        var interpretted = this.$super(value);\n\n        return (\n            interpretted === \"\"\n            ? NaN\n            : Math.floor(interpretted)\n        );\n\n    }\n\n});\n\n/**\n * Handles number values.\n *\n * @class ARIA.Integer\n * @extends ARIA.Property\n */\nARIA.Number = ARIA.createClass(ARIA.Property, {\n\n    /**\n     * @inheritDoc\n     */\n    init: function (element, attribute) {\n\n        this.$super(element, attribute);\n        this.setPattern(/^(\\d+(\\.\\d+)?)|\\.\\d+$/);\n\n    },\n\n    /**\n     * Interprets the value as a number. If the value can't be converted into a\n     * number, NaN is returned.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Number}\n     *         Number value.\n     */\n    interpret: function (value) {\n\n        var interpretted = this.$super(value);\n\n        return (\n            interpretted === \"\"\n            ? NaN\n            : parseFloat(interpretted)\n        );\n\n    }\n\n});\n\n/**\n * Handles WAI-ARIA states.\n *\n * @class ARIA.State\n * @extends ARIA.Property\n */\nARIA.State = ARIA.createClass(ARIA.Property, /** @lends ARIA.State.prototype */{\n\n    /**\n     * Ensures that the given value is either a boolean or a string of \"true\" or\n     * \"false\". {@link ARIA.Property#tokens} and {@link ARIA.Property#pattern}\n     * are ignored.\n     *\n     * @param  {?} value\n     *         Value to check.\n     * @return {Boolean}\n     *         true if the token is valid, false otherwise.\n     */\n    isValidToken: function (value) {\n\n        return (\n            typeof value === \"boolean\"\n            || value === \"true\"\n            || value === \"false\"\n        );\n\n    },\n\n    /**\n     * Coerces the given value into a boolean.\n     *\n     * @param  {?} value\n     *         Value to coerce.\n     * @return {Boolean|String}\n     *         Coerced boolean or an empty string.\n     */\n    interpret: function (value) {\n\n        return (\n            typeof value === \"boolean\"\n            ? value === true\n            : (\n                (value === \"true\" || value === \"false\")\n                ? value === \"true\"\n                : \"\"\n            )\n        );\n\n    }\n\n});\n\n/**\n * Handles a WAI-ARIA state that can be true or false but can also be undefined.\n *\n * @class ARIA.UndefinedState\n * @extends ARIA.State\n */\nARIA.UndefinedState = ARIA.createClass(ARIA.State, /** @lends ARIA.UndefinedState.prototype */{\n\n    /**\n     * Allows for true, false or undefined.\n     *\n     * @inheritDoc\n     */\n    isValidToken: function (value) {\n\n        return (\n            value === undefined\n            || value === \"undefined\"\n            || this.$super(value)\n        );\n\n    },\n\n    /**\n     * Interprets undefined as \"undefined.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Boolean|String}\n     *         Either the boolean value, \"undefined\" or an empty string if the\n     *         value is not understood.\n     */\n    interpret: function (value) {\n\n        return (\n            (value === undefined || value === \"undefined\")\n            ? \"undefined\"\n            : this.$super(value)\n        );\n\n    },\n\n    /**\n     * Returns a boolean or undefined.\n     *\n     * @return {Boolean|undefined}\n     *         Value of the attribute.\n     */\n    get: function () {\n\n        var value = this.$super();\n\n        if (value === \"undefined\") {\n            value = undefined;\n        }\n\n        return value;\n\n    }\n\n});\n\n/**\n * Handles WAI-ARIA tristates. That is, a state that can be either true, false\n * or \"mixed\".\n *\n * @class ARIA.Tristate\n * @extends ARIA.State\n */\nARIA.Tristate = ARIA.createClass(ARIA.State, /** @lends ARIA.Tristate.prototype */{\n\n    /**\n     * Allows the token \"mixed\".\n     *\n     * @inheritDoc\n     */\n    isValidToken: function (value) {\n        return value === \"mixed\" || this.$super(value);\n    },\n\n    /**\n     * Allows the token \"mixed\".\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Boolean|String}\n     *         Either the boolean value, \"mixed\" or an empty string if the value\n     *         is not understood.\n     */\n    interpret: function (value) {\n\n        return (\n            value === \"mixed\"\n            ? value\n            : this.$super(value)\n        );\n\n    }\n\n});\n\n/**\n * The arrays for {@link ARIA.List} instances. This prevents the array from\n * being exposed and manipulated.\n * @private\n * @type {WeakMap}\n */\nvar lists = new WeakMap();\n\n/**\n * Creates an iterator.\n *\n * @private\n * @param   {ARIA.List} instance\n *          Instance that should gain an iterator.\n * @param   {Function} valueMaker\n *          Function to get the iterator value from the item.\n * @return  {Object}\n *          Iterator response.\n */\nvar makeIterator = function (instance, valueMaker) {\n\n   var index = 0;\n   var list = instance.get();\n   var length = list.length;\n\n   return {\n\n       next: function () {\n\n           var iteratorValue = {\n               value: valueMaker(list, index),\n               done: index >= length\n           };\n\n           index += 1;\n\n           return iteratorValue;\n\n       },\n\n       toString: function () {\n           return \"Array Iterator\";\n       }\n\n   };\n\n};\n\n/**\n * A version of DOMException that we can actually create.\n *\n * @class\n * @private\n * @extends Error\n * @param   {String} type\n *          Type of exception.\n * @param   {String} message\n *          Message for the exception.\n */\nvar DOMEx = function (type, message) {\n\n    this.name = type;\n    this.code = DOMException[type];\n    this.message = message;\n\n};\nDOMEx.prototype = Error.prototype;\n// DOMEx taken from:\n// https://github.com/yola/classlist-polyfill/blob/master/src/index.js\n\n/**\n * Handles a WAI-ARIA attribute that should be a space-separated list. This is\n * moddled on DOMTokenList (such as classList) so it will only accept unique\n * values and will throw errors for invalid values (see\n * {@link ARIA.List#isValidToken}).\n *\n * @class ARIA.List\n * @extends ARIA.Property\n */\nARIA.List = ARIA.createClass(ARIA.Property, /** ARIA.List.prototype */{\n\n    /**\n     * @inheritDoc\n     */\n    init: function (element, attribute) {\n\n        var that = this;\n\n        lists.set(that, []);\n\n        /**\n         * The number of items in this list.\n         *\n         * @name length\n         * @memberof ARIA.List\n         * @instance\n         * @type {Number}\n         */\n        Object.defineProperty(that, \"length\", {\n\n            get: function () {\n                return lists.get(that).length;\n            }\n\n        });\n\n        this.$super(element, attribute);\n\n    },\n\n    /**\n     * Ensures that the token is valid.\n     *\n     * @param  {?} token\n     *         Token to check.\n     * @return {Boolean}\n     *         true if the token is valid, false otherwise.\n     * @throws {DOMEx}\n     *         Given token cannot be an empty string.\n     * @throws {DOMEx}\n     *         Given token cannot contain a space.\n     */\n    isValidToken: function (token) {\n\n        if (token === \"\") {\n\n            throw new DOMEx(\n                \"SYNTAX_ERR\",\n                \"An invalid or illegal string was specified\"\n            );\n\n        }\n\n        if ((/\\s/).test(token)) {\n\n            throw new DOMEx(\n                \"INVALID_CHARACTER_ERR\",\n                \"String contains an invalid character\"\n            );\n\n        }\n\n        return this.$super(token);\n\n    },\n\n    /**\n     * Coerces the values into a string and splits it at the spaces.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Array.<String>}\n     *         Array of strings.\n     */\n    interpret: function (value) {\n\n        var val = (\n            Array.isArray(value)\n            ? value.join(\" \")\n            : value\n        );\n        var string = this.$super(val);\n\n        return (\n            string.length\n            ? string.split(/\\s+/)\n            : []\n        );\n\n    },\n\n    /**\n     * Sets the value of the list to be the given value, removing all previous\n     * values first. To add to the previous values, use {@link ARIA.List#add}.\n     * The values are interpretted as an array (see {@link ARIA.List#interpret}\n     * and validated (see {@link ARIA.List#isValidToken}); only unique values\n     * are added.\n     *\n     * @param {?} value\n     *        Value(s) to add. If the given value is a string, it is assumed to\n     *        be a space-separated list.\n     */\n    set: function (value) {\n\n        var values = this.interpret(value);\n        var unwanted = this\n            .toArray()\n            .filter(function (item) {\n                return values.indexOf(item) < 0;\n            });\n\n        if (values.length) {\n            this.add.apply(this, values);\n        }\n\n        if (unwanted.length) {\n            this.remove.apply(this, unwanted);\n        }\n\n        this.setAttribute(this.toString());\n\n    },\n\n    /**\n     * Gets the value of the attribute as an array.\n     *\n     * @return {Array.<String>}\n     *         Value of the attribute as an array.\n     */\n    get: function () {\n        return this.interpret(this.toString());\n    },\n\n    /**\n     * Checks to see if the attribute is set. If a parameter is passed, the list\n     * is checked to see if it contains the value.\n     *\n     * @param  {String} [item]\n     *         Optional value to check.\n     * @return {Boolean}\n     *         true if the attribute exists or the value is in the list, false\n     *         otherwise.\n     */\n    has: function (item) {\n\n        return (\n            item === undefined\n            ? this.hasAttribute()\n            : this.contains(item)\n        );\n\n    },\n\n    /**\n     * Converts the attribute into a string. Optionally, a string can be passed\n     * to be used as the glue for the array.\n     *\n     * @param  {String} [glue=\" \"]\n     *         Optional glue to use to join the array.\n     * @return {String}\n     *         String from the list.\n     */\n    toString: function (glue) {\n\n        if (glue === undefined) {\n            glue = \" \";\n        }\n\n        return lists.get(this).join(glue);\n\n    },\n\n    /**\n     * Adds the given values to the list. Items are only added if they're valid\n     * (see {@link ARIA.List#isValidToken}) and not already in the list.\n     *\n     * @param {String} ...arguments\n     *        Arguments to add.\n     */\n    add: function () {\n\n        var list = lists.get(this);\n\n        if (arguments.length) {\n\n            arrayFrom(arguments, function (argument) {\n\n                var item = this.interpret(argument)[0];\n\n                if (this.isValidToken(item) && list.indexOf(item) < 0) {\n                    list.push(item);\n                }\n\n            }, this);\n\n            this.setAttribute(this.toString());\n\n        }\n\n    },\n\n    /**\n     * Either removes one or more values from the list or the attribute itself\n     * if no parameters are passed.\n     *\n     * @param {String} [...arguments]\n     *        Optional values to remove.\n     */\n    remove: function () {\n\n        var list = lists.get(this);\n        var string;\n\n        if (arguments.length) {\n\n            arrayFrom(arguments, function (argument) {\n\n                var item = this.interpret(argument)[0];\n                var index = this.isValidToken(item) && list.indexOf(item);\n\n                if (index > -1) {\n                    list.splice(index, 1);\n                }\n\n            }, this);\n\n            string = this.toString();\n\n            if (string === \"\") {\n                this.removeAttribute();\n            } else {\n                this.setAttribute(string);\n            }\n\n        } else {\n\n            list.length = 0;\n            this.removeAttribute();\n\n        }\n\n    },\n\n    /**\n     * Checks to see if the given item is within the list.\n     *\n     * @param  {String} item\n     *         Item to check for.\n     * @return {Boolean}\n     *         true if the item is within the list, false otherwise.\n     */\n    contains: function (item) {\n\n        var value = this.interpret(item)[0];\n\n        return this.isValidToken(value) && lists.get(this).indexOf(value) > -1;\n\n    },\n\n    /**\n     * Gets the item from the list at the specified index. If there is no item\n     * at that index, null is returned.\n     *\n     * @param  {Number} index\n     *         Index of the item to retrieve.\n     * @return {String|null}\n     *         The item at the given index or null if there is no item at that\n     *         index.\n     */\n    item: function (index) {\n        return lists.get(this)[Math.floor(index)] || null;\n    },\n\n    /**\n     * Replaces one value with another one.\n     *\n     * @param  {String} oldToken\n     *         Old value to replace.\n     * @param  {String} newToken\n     *         New token.\n     * @return {Boolean}\n     *         true if a replacement was made, false otherwise.\n     */\n    replace: function (oldToken, newToken) {\n\n        var isReplaced = false;\n        var list;\n        var index;\n        var oldItem = this.interpret(oldToken)[0];\n        var newItem = this.interpret(newToken)[0];\n\n        if (this.isValidToken(oldItem) && this.isValidToken(newItem)) {\n\n            list = lists.get(this);\n            index = list.indexOf(oldItem);\n\n            if (index > -1) {\n\n                list.splice(index, 1, newItem);\n                isReplaced = true;\n\n            }\n\n        }\n\n        return isReplaced;\n\n    },\n\n    /**\n     * Loops over the items within the array.\n     *\n     * @param {Function} handler\n     *        Function to execute on each item.\n     * @param {?} [context]\n     *        Optional context for the function.\n     */\n    forEach: function (handler, context) {\n        lists.get(this).forEach(handler, context);\n    },\n\n    /**\n     * Converts the list into an array. Optionally, the values can be converted\n     * by passing a mapping function.\n     *\n     * @param  {Function} [map]\n     *         Optional conversion function.\n     * @param  {?} context\n     *         Optional context for the optional function.\n     * @return {Array}\n     *         Array made from the list.\n     */\n    toArray: function (map, context) {\n        return arrayFrom(lists.get(this), map, context);\n    },\n\n    /**\n     * Returns an iterator for the entries.\n     *\n     * @return {Object}\n     *         Iterator value.\n     */\n    entries: function () {\n\n        return makeIterator(this, function (list, index) {\n            return [index, list[index]];\n        });\n\n    },\n\n    /**\n     * Returns an iterator for the keys.\n     *\n     * @return {Object}\n     *         Iterator value.\n     */\n    keys: function () {\n\n        return makeIterator(this, function (list, index) {\n            return index;\n        });\n\n    },\n\n    /**\n     * Returns an iterator for the values.\n     *\n     * @return {Object}\n     *         Iterator value.\n     */\n    values: function () {\n\n        return makeIterator(this, function (list, index) {\n            return list[index];\n        });\n\n    }\n\n});\n\nif (window.Symbol && Symbol.iterator) {\n    ARIA.List.prototype[Symbol.iterator] = ARIA.List.prototype.values;\n}\n\n/**\n * Handles WAI-ARIA attributes that reference a single ID.\n *\n * @class ARIA.Reference\n * @extends ARIA.Property\n */\nARIA.Reference = ARIA.createClass(ARIA.Property, /** @lends ARIA.Reference.prototype */{\n\n    /**\n     * Interprets the given value as a string. If the value is an element, the\n     * element's ID is returned, generating one if necessary - see\n     * {@link ARIA.identify}.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {String}\n     *         The interpretted value.\n     */\n    interpret: function (value) {\n        return ARIA.Reference.interpret(value);\n    },\n\n    /**\n     * Gets the element referenced by this attribute. If the element cannot be\n     * found or the attribute isn't set, null is returned.\n     *\n     * @return {Element|null}\n     *         Element referenced by this attribute or null if the element\n     *         cannot be found or the attribute isn't set.\n     */\n    get: function () {\n        return ARIA.getById(this.getAttribute());\n    },\n\n    /**\n     * Checks to see if attribute is set and the element referenced by the\n     * attribute exists, returning true if both are true.\n     *\n     * @return {Boolean}\n     *         true if the attribute exists and references an existing element,\n     *         false otherwise.\n     */\n    has: function () {\n        return this.hasAttribute() && this.get() !== null;\n    }\n\n});\n\n/**\n * Interprets the given value as a string. If the value is an element, the\n * element's ID is returned, generating one if necessary = see\n * {@link ARIA.identify}. This powers {@link ARIA.Reference#interpret} while\n * also allowing other functions and classes to use it.\n *\n * @param  {?} value\n *         Value to interpret.\n * @return {String}\n *         The interpretted value.\n */\nARIA.Reference.interpret = function (value) {\n\n    return (\n        ARIA.isNode(value)\n        ? ARIA.identify(value)\n        : ARIA.Property.interpret(value)\n    );\n\n};\n\n/**\n * Handles WAI-ARIA attributes that handle space-separated lists of IDs.\n * @class ARIA.ReferenceList\n * @extends ARIA.List\n */\nARIA.ReferenceList = ARIA.createClass(ARIA.List, {\n\n    /**\n     * Interprets an element, ID or array of elements or/and IDs as an array of\n     * element IDs.\n     *\n     * @param  {Array.<Element|String>|Element|String} value\n     *         Value(s) to interpret.\n     * @return {Array.<String>}\n     *         Collection of IDs.\n     */\n    interpret: function (value) {\n\n        var interpretted = [];\n\n        if (\n            value\n            && typeof value === \"object\"\n            && typeof value.length === \"number\"\n        ) {\n            interpretted = arrayFrom(value, ARIA.Reference.interpret, this);\n        } else if (typeof value === \"string\") {\n            interpretted = this.$super(value);\n        } else {\n            interpretted = [ARIA.Reference.interpret(value)];\n        }\n\n        // Remove all falsy values such as \"\" or null.\n        return interpretted.filter(Boolean);\n\n    },\n\n    /**\n     * Gets an array of elements referenced by the attribute. If the element\n     * cannot be found, null will be in place of the element.\n     *\n     * @return {Array.<Element|null>}\n     *         Array of elements.\n     */\n    get: function () {\n        return this.toArray(ARIA.getById);\n    },\n\n    /**\n     * Checks to see either if the attribute exists and all elements exist or,\n     * if a parameter is passed, whether or not that item appears within the\n     * list.\n     *\n     * @param  {Element|String} [item]\n     *         Optional item to check for.\n     * @return {Boolean}\n     *         true if the attribute exists and all elements exist or, if a\n     *         parameter is passed, true if the list contains the value.\n     */\n    has: function (item) {\n\n        return this.hasAttribute() && (\n            item === undefined\n            ? this.get().filter(Boolean).length === this.length\n            : this.contains(item)\n        );\n\n    }\n\n});\n\n/**\n * Handles the WAI-ARIA attributes on an element.\n *\n * @class ARIA.Element\n */\nARIA.Element = ARIA.createClass(/** @lends ARIA.ELement.prototype */{\n\n    /**\n     * @constructs ARIA.Element\n     * @param      {Element} element\n     *             Element whose WAI-ARIA attributes should be handled.\n     */\n    init: function (element) {\n\n        /**\n         * Element whose WAI-ARIA attributes should be handled.\n         * @type {Element}\n         */\n        this.element = element;\n\n        /**\n         * A flag object that keeps track of attributes being modified. Prevents\n         * infinitely loops being caused in the MutationObserver.\n         * @type {Object}\n         */\n        this.manipulationFlags = Object.create(null);\n\n        this.preloadAttributes();\n        this.readAttributes();\n        this.observeAttributes();\n\n    },\n\n    /**\n     * Creates placeholders for all the WAI-ARIA attributes that are in\n     * {@link ARIA.factories}. The factories are lazy-loaded so they're only\n     * instantiated as needed.\n     */\n    preloadAttributes: function () {\n\n        Object.keys(ARIA.factories).forEach(function (attribute) {\n\n            var value;\n\n            Object.defineProperty(this, attribute, {\n\n                get: function () {\n\n                    if (!value) {\n\n                        value = ARIA.runFactory(\n                            attribute,\n                            this.element,\n                            ARIA.normalise(attribute)\n                        );\n\n                    }\n\n                    return value;\n\n                },\n\n                set: function (value) {\n                    this[attribute].set(value);\n                }\n\n            });\n\n        }, this);\n\n\n    },\n\n    /**\n     * Reads all teh WAI-ARIA attributes on {@link ARIA.Element#element} and\n     * sets the {@link ARIA.Property} values.\n     */\n    readAttributes: function () {\n\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        arrayFrom(this.element.attributes, function (attribute) {\n\n            var name = attribute.name.replace(/^aria\\-/, \"\");\n\n            if (hasOwnProperty.call(this, name)) {\n                this[name].set(attribute.value);\n            }\n\n        }, this);\n\n    },\n\n    /**\n     * Creates the observer {@link ARIA.Element#observer} that listens for\n     * changes to WAI-ARIA attribtues and updates the {@link ARIA.Property}\n     * values.\n     */\n    observeAttributes: function () {\n\n        var that = this;\n        var element = that.element;\n        var observer = new MutationObserver(function (mutations) {\n\n            mutations.forEach(function (mutation) {\n\n                var attribute = mutation.attributeName || \"\";\n                var suffix = attribute.slice(5);\n                var value;\n                var old;\n\n                if (\n                    mutation.type === \"attributes\"\n                    && ARIA.factories[suffix]\n                    && !that.manipulationFlags[suffix]\n                ) {\n\n                    that.manipulationFlags[suffix] = true;\n\n                    if (ARIA.hasAttribute(element, attribute)) {\n\n                        value = ARIA.Property.interpret(\n                            ARIA.getAttribute(element, attribute)\n                        );\n                        old = ARIA.Property.interpret(mutation.oldValue);\n\n                        if (value !== old) {\n                            that[suffix].set(value);\n                        }\n\n                    } else {\n                        that[suffix].remove();\n                    }\n\n                    window.setTimeout(function () {\n                        delete that.manipulationFlags[suffix];\n                    }, 0);\n\n                }\n\n            });\n\n        });\n\n        observer.observe(element, {\n            attributes: true,\n            attributeOldValue: true\n        });\n\n        /**\n         * The observer.\n         * @type {MutationObserver}\n         */\n        that.observer = observer;\n\n    },\n\n    /**\n     * Disconnects {@link ARIA.Element#observer}.\n     */\n    disconnectAttributes: function () {\n        this.observer.disconnect();\n    }\n\n});\n\n/**\n * Helper function for creating the factories.\n *\n * @private\n * @param   {Function} Constructor\n *          Constructor function for creating the element.\n * @param   {Array} [tokens]\n *          Optional tokens for the attribute.\n * @return  {Function}\n *          Function that will create the Constructor.\n */\nvar makeFactory = function (Constructor, tokens) {\n\n    return function (element, attribute) {\n\n        var property = new Constructor(element, attribute);\n\n        if (tokens && tokens.length) {\n            property.setTokens(tokens);\n        }\n\n        return property;\n\n    };\n\n};\n\nvar AriaProperty = ARIA.Property;\nvar AriaList = ARIA.List;\nvar factoryEntries = [\n    [AriaProperty, [\n        \"keyshortcuts\",\n        \"label\",\n        \"placeholder\",\n        \"roledescription\",\n        \"valuetext\"\n    ]],\n    [ARIA.Reference, [\n        \"activedescendant\",\n        \"details\",\n        \"errormessage\"\n    ]],\n    [ARIA.ReferenceList, [\n        \"controls\",\n        \"describedby\",\n        \"flowto\",\n        \"labelledby\",\n        \"owns\"\n    ]],\n    [ARIA.State, [\n        \"atomic\",\n        \"busy\",\n        \"disabled\",\n        \"modal\",\n        \"multiline\",\n        \"multiselectable\",\n        \"readonly\",\n        \"required\"\n    ]],\n    [ARIA.Tristate, [\n        \"checked\",\n        \"pressed\"\n    ]],\n    [ARIA.UndefinedState, [\n        \"expanded\",\n        \"grabbed\",\n        \"hidden\",\n        \"selected\"\n    ]],\n    [ARIA.Integer, [\n        \"colcount\",\n        \"colindex\",\n        \"colspan\",\n        \"level\",\n        \"posinset\",\n        \"rowcount\",\n        \"rowindex\",\n        \"rowspan\",\n        \"setsize\"\n    ]],\n    [ARIA.Number, [\n        \"valuemax\",\n        \"valuemin\",\n        \"valuenow\"\n    ]],\n    [AriaProperty, [\"autocomplete\"], [\n        \"none\",\n        \"inline\",\n        \"list\",\n        \"both\"\n    ]],\n    [AriaProperty, [\"current\"], [\n        \"false\",\n        \"true\",\n        \"page\",\n        \"step\",\n        \"location\",\n        \"date\",\n        \"time\"\n    ]],\n    [AriaProperty, [\"haspopup\"], [\n        \"false\",\n        \"true\",\n        \"menu\",\n        \"listbox\",\n        \"tree\",\n        \"grid\",\n        \"dialog\"\n    ]],\n    [AriaProperty, [\"invalid\"], [\n        \"false\",\n        \"true\",\n        \"grammar\",\n        \"spelling\"\n    ]],\n    [AriaProperty, [\"live\"], [\n        \"off\",\n        \"assertive\",\n        \"polite\"\n    ]],\n    [AriaProperty, [\"orientation\"], [\n        undefined,\n        \"undefined\",\n        \"horizontal\",\n        \"vertical\"\n    ]],\n    [AriaProperty, [\"sort\"], [\n        \"none\",\n        \"ascending\",\n        \"descending\",\n        \"other\"\n    ]],\n    [AriaList, [\"dropeffect\"], [\n        \"none\",\n        \"copy\",\n        \"execute\",\n        \"link\",\n        \"move\",\n        \"popup\"\n    ]],\n    [AriaList, [\"relevant\"], [\n        \"additions\",\n        \"all\",\n        \"removals\",\n        \"text\"\n    ]]\n];\n\nfactoryEntries.forEach(function (entry) {\n\n    entry[1].forEach(function (property) {\n        ARIA.factories[property] = makeFactory(entry[0], entry[2]);\n    });\n\n});\n\nARIA.addAlias(\"labelledby\", \"labeledby\");\n\n// https://github.com/LeaVerou/bliss/issues/49\nfunction addNodeProperty(name, valueMaker, settings) {\n\n    var descriptor = {\n\n        configurable: true,\n\n        get: function getter() {\n\n            Object.defineProperty(Node.prototype, name, {\n                get: undefined\n            });\n\n            Object.defineProperty(this, name, {\n                value: valueMaker(this)\n            });\n\n            Object.defineProperty(Node.prototype, name, {\n                get: getter\n            });\n\n            return this[name];\n\n        }\n\n    };\n\n    if (settings) {\n\n        Object.keys(settings).forEach(function (key) {\n            descriptor[key] = settings[key];\n        });\n\n    }\n\n    Object.defineProperty(Node.prototype, name, descriptor);\n\n}\n\naddNodeProperty(\"aria\", function (context) {\n    return new ARIA.Element(context);\n});\n\n// \"Authors MUST NOT use abstract roles in content.\"\n// https://www.w3.org/TR/wai-aria-1.1/#abstract_roles\nvar roles = [\n    \"alert\",\n    \"alertdialog\",\n    \"application\",\n    \"article\",\n    \"banner\",\n    \"button\",\n    \"cell\",\n    \"checkbox\",\n    \"columnheader\",\n    \"complementary\",\n    \"combobox\",\n    // \"command\", // (abstract)\n    // \"composite\", // (abstract)\n    \"contentinfo\",\n    \"definition\",\n    \"dialog\",\n    \"directory\",\n    \"document\",\n    \"feed\",\n    \"figure\",\n    \"form\",\n    \"grid\",\n    \"gridcell\",\n    \"group\",\n    \"heading\",\n    \"img\",\n    // \"input\", // (abstract)\n    // \"landmark\", // (abstract)\n    \"link\",\n    \"list\",\n    \"listbox\",\n    \"listitem\",\n    \"log\",\n    \"main\",\n    \"marquee\",\n    \"math\",\n    \"menu\",\n    \"menubar\",\n    \"menuitem\",\n    \"menuitemcheckbox\",\n    \"menuitemradio\",\n    \"navigation\",\n    \"none\",\n    \"note\",\n    \"option\",\n    \"presentation\",\n    \"progressbar\",\n    \"radio\",\n    \"radiogroup\",\n    // \"range\", // (abstract)\n    \"region\",\n    // \"roletype\", // (abstract)\n    \"row\",\n    \"rowgroup\",\n    \"rowheader\",\n    \"scrollbar\",\n    \"search\",\n    \"searchbox\",\n    // \"section\", // (abstract)\n    // \"sectionhead\", // (abstract)\n    // \"select\", // (abstract)\n    \"separator\",\n    \"slider\",\n    \"spinbutton\",\n    \"status\",\n    // \"structure\", // (abstract)\n    \"switch\",\n    \"tab\",\n    \"table\",\n    \"tablist\",\n    \"tabpanel\",\n    \"term\",\n    \"textbox\",\n    \"timer\",\n    \"toolbar\",\n    \"tooltip\",\n    \"tree\",\n    \"treegrid\",\n    \"treeitem\"\n    // \"widget\", // (abstract)\n    // \"window\", // (abstract)\n];\n\naddNodeProperty(\"role\", function (context) {\n\n    var list = new AriaList(context, \"role\");\n\n    list.setTokens(roles);\n\n    return list;\n\n}, {\n\n    set: function (value) {\n        this.role.set(value);\n    }\n\n});\n\nglobalVariable.ARIA = ARIA;\n}(window));"],"file":"aria.min.js"}