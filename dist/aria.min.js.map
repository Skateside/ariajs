{"version":3,"sources":["aria.js"],"names":["globalVariable","identity","x","slice","arrayLike","offset","Array","prototype","call","arrayFrom","from","map","context","undefined","objectAssign","Object","assign","source","arguments","forEach","object","keys","key","noop","fnTest","test","ARIA","factories","create","translate","tokens","aria-autocomplete","aria-current","aria-dropeffect","aria-haspopup","aria-invalid","aria-live","aria-orientation","aria-relevant","aria-sort","role","defineProperty","configurable","enumerable","writable","value","getFactory","attribute","normalise","runFactory","factory","ReferenceError","apply","addAlias","aliases","normalSource","isArray","alias","normalAlias","normal","String","toLowerCase","replace","normaliseDescriptor","get","set","normaliser","addClassMethods","name","method","parent","this","returnValue","hasSuper","temp","$super","defineProperties","normalize","createClass","Base","proto","Class","init","addMethod","addMethods","constructor","setAttribute","element","getAttribute","hasAttribute","removeAttribute","is","Element","matches","selector","msMatchesSelector","elements","document","querySelectorAll","length","isMatch","getById","id","getElementById","counter","defaultIdentifyPrefix","identify","prefix","isNode","Node","FOCUSABLE","makeFocusable","tabindex","forceTabindex","Math","floor","max","min","isNaN","resetFocusable","WARNING_INVALID_TOKEN","supplant","string","info","whole","index","arg","enableWarnings","warn","message","console","Property","interpret","isValidToken","token","isValid","indexOf","interpretted","toString","trim","Number","parseFloat","Integer","State","isTrue","UndefinedState","push","Tristate","List","list","val","join","split","that","values","reduce","unique","concat","Reference","ReferenceList","filter","Boolean","manipulationFlags","preloadAttributes","readAttributes","observeAttributes","instance","createValue","hasOwnProperty","attributes","observer","MutationObserver","mutations","mutation","attributeName","suffix","type","oldValue","window","setTimeout","observe","attributeOldValue","disconnectAttributes","disconnect","entry"],"mappings":"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","sourcesContent":["/*! ariajs - v0.2.0 - MIT license - https://github.com/Skateside/ariajs - 2018-11-8 */\n(function (globalVariable) {\n    \"use strict\";\n\n/**\r\n * A function that returns the given variable unchanged.\r\n *\r\n * @private\r\n * @param   {?} x\r\n *          Variable to return.\r\n * @return  {?}\r\n *          Unmodified original variable.\r\n */\r\nvar identity = function (x) {\r\n    return x;\r\n};\r\n\r\n/**\r\n * A simple wrapper for Array#slice.\r\n *\r\n * @private\r\n * @param   {Array|Object} arrayLike\r\n *          Array or array-like structure to slice.\r\n * @param   {Number} [offset]\r\n *          Optional offset for the slice.\r\n * @return  {Array}\r\n *          Sliced array.\r\n */\r\nvar slice = function (arrayLike, offset) {\r\n    return Array.prototype.slice.call(arrayLike, offset);\r\n};\r\n\r\n/**\r\n * A simple fall-back for Array.from.\r\n *\r\n * @private\r\n * @param   {Object} arrayLike\r\n *          Array-like structure.\r\n * @param   {Function} [map=identity]\r\n *          Optional function to convert the values.\r\n * @param   {?} [context]\r\n *          Optional context for the map function.\r\n * @return  {Array}\r\n *          Array made from the iven array-like structure.\r\n */\r\nvar arrayFrom = Array.from || function (arrayLike, map, context) {\r\n\r\n    if (map === undefined) {\r\n        map = identity;\r\n    }\r\n\r\n    return Array.prototype.map.call(arrayLike, map, context);\r\n\r\n};\r\n\r\n/**\r\n * A simple fall-back for Object.assign.\r\n *\r\n * @private\r\n * @param   {Object} source\r\n *          Source object to modify.\r\n * @param   {Object} [...objects]\r\n *          Additional objects to extend the first.\r\n * @return  {Object}\r\n *          Extended object.\r\n */\r\nvar objectAssign = Object.assign || function (source) {\r\n\r\n    slice(arguments, 1).forEach(function (object) {\r\n\r\n        if (object) {\r\n\r\n            Object.keys(object).forEach(function (key) {\r\n                source[key] = object[key];\r\n            });\r\n\r\n        }\r\n\r\n    });\r\n\r\n    return source;\r\n\r\n};\r\n\r\n/**\r\n * A function that does nothing.\r\n *\r\n * @private\r\n */\r\nvar noop = function () {\r\n    return;\r\n};\r\n\r\nvar fnTest = (\r\n    (/return/).test(noop)\r\n    ? (/[.'\"]\\$super\\b/)\r\n    : (/.*/)\r\n);\r\n\r\n/**\r\n * @namespace\r\n */\r\nvar ARIA = {\r\n\r\n    /**\r\n     * Collection of factories for creating WAI-ARIA libraries. The attribute\r\n     * key should be the attribute suffixes (e.g. \"label\" for \"aria-label\" etc.)\r\n     * @type {Object}\r\n     */\r\n    factories: Object.create(null),\r\n\r\n    /**\r\n     * Map of all mis-spellings and aliases. The attribute key should be the\r\n     * normalised value - see {@link ARIA.normalise}.\r\n     * @type {Object}\r\n     */\r\n    translate: Object.create(null),\r\n\r\n    /**\r\n     * Collection of all valid tokens for any given attribute. The attribute\r\n     * key should be the normalised value - see {@link ARIA.normalise}.\r\n     * @type {[type]}\r\n     */\r\n    tokens: objectAssign(Object.create(null), {\r\n        \"aria-autocomplete\": [\r\n            \"none\",\r\n            \"inline\",\r\n            \"list\",\r\n            \"both\"\r\n        ],\r\n        \"aria-current\": [\r\n            \"false\",\r\n            \"true\",\r\n            \"page\",\r\n            \"step\",\r\n            \"location\",\r\n            \"date\",\r\n            \"time\"\r\n        ],\r\n        \"aria-dropeffect\": [\r\n            \"none\",\r\n            \"copy\",\r\n            \"execute\",\r\n            \"link\",\r\n            \"move\",\r\n            \"popup\"\r\n        ],\r\n        \"aria-haspopup\": [\r\n            \"false\",\r\n            \"true\",\r\n            \"menu\",\r\n            \"listbox\",\r\n            \"tree\",\r\n            \"grid\",\r\n            \"dialog\"\r\n        ],\r\n        \"aria-invalid\": [\r\n            \"false\",\r\n            \"true\",\r\n            \"grammar\",\r\n            \"spelling\"\r\n        ],\r\n        \"aria-live\": [\r\n            \"off\",\r\n            \"assertive\",\r\n            \"polite\"\r\n        ],\r\n        \"aria-orientation\": [\r\n            undefined,\r\n            \"undefined\",\r\n            \"horizontal\",\r\n            \"vertical\"\r\n        ],\r\n        \"aria-relevant\": [\r\n            \"additions\",\r\n            \"all\",\r\n            \"removals\",\r\n            \"text\"\r\n        ],\r\n        \"aria-sort\": [\r\n            \"none\",\r\n            \"ascending\",\r\n            \"descending\",\r\n            \"other\"\r\n        ],\r\n        // \"Authors MUST NOT use abstract roles in content.\"\r\n        // https://www.w3.org/TR/wai-aria-1.1/#abstract_roles\r\n        \"role\": [\r\n            \"alert\",\r\n            \"alertdialog\",\r\n            \"application\",\r\n            \"article\",\r\n            \"banner\",\r\n            \"button\",\r\n            \"cell\",\r\n            \"checkbox\",\r\n            \"columnheader\",\r\n            \"complementary\",\r\n            \"combobox\",\r\n            // \"command\", // (abstract)\r\n            // \"composite\", // (abstract)\r\n            \"contentinfo\",\r\n            \"definition\",\r\n            \"dialog\",\r\n            \"directory\",\r\n            \"document\",\r\n            \"feed\",\r\n            \"figure\",\r\n            \"form\",\r\n            \"grid\",\r\n            \"gridcell\",\r\n            \"group\",\r\n            \"heading\",\r\n            \"img\",\r\n            // \"input\", // (abstract)\r\n            // \"landmark\", // (abstract)\r\n            \"link\",\r\n            \"list\",\r\n            \"listbox\",\r\n            \"listitem\",\r\n            \"log\",\r\n            \"main\",\r\n            \"marquee\",\r\n            \"math\",\r\n            \"menu\",\r\n            \"menubar\",\r\n            \"menuitem\",\r\n            \"menuitemcheckbox\",\r\n            \"menuitemradio\",\r\n            \"navigation\",\r\n            \"none\",\r\n            \"note\",\r\n            \"option\",\r\n            \"presentation\",\r\n            \"progressbar\",\r\n            \"radio\",\r\n            \"radiogroup\",\r\n            // \"range\", // (abstract)\r\n            \"region\",\r\n            // \"roletype\", // (abstract)\r\n            \"row\",\r\n            \"rowgroup\",\r\n            \"rowheader\",\r\n            \"scrollbar\",\r\n            \"search\",\r\n            \"searchbox\",\r\n            // \"section\", // (abstract)\r\n            // \"sectionhead\", // (abstract)\r\n            // \"select\", // (abstract)\r\n            \"separator\",\r\n            \"slider\",\r\n            \"spinbutton\",\r\n            \"status\",\r\n            // \"structure\", // (abstract)\r\n            \"switch\",\r\n            \"tab\",\r\n            \"table\",\r\n            \"tablist\",\r\n            \"tabpanel\",\r\n            \"term\",\r\n            \"textbox\",\r\n            \"timer\",\r\n            \"toolbar\",\r\n            \"tooltip\",\r\n            \"tree\",\r\n            \"treegrid\",\r\n            \"treeitem\"\r\n            // \"widget\", // (abstract)\r\n            // \"window\", // (abstract)\r\n        ]\r\n    })\r\n\r\n};\r\n\r\n/**\r\n * The version of the library.\r\n *\r\n * @memberof ARIA\r\n * @type {String}\r\n * @constant\r\n * @name VERSION\r\n */\r\nObject.defineProperty(ARIA, \"VERSION\", {\r\n    configurable: false,\r\n    enumerable: true,\r\n    writable: false,\r\n    value: \"0.2.0\"\r\n});\r\n\r\n/**\r\n * Gets the factory from {@link ARIA.factories} that matches either the given\r\n * attribute or the normalised version (see {@link ARIA.normalise}).\r\n *\r\n * @param  {String} attribute\r\n *         Attribute whose factory should be returned.\r\n * @return {Function}\r\n *         Factory for creating the attribute.\r\n */\r\nARIA.getFactory = function (attribute) {\r\n\r\n    return (\r\n        ARIA.factories[attribute]\r\n        || ARIA.factories[ARIA.normalise(attribute)]\r\n    );\r\n\r\n};\r\n\r\n/**\r\n * Executes the factory for the given attribute, passing in given parameters.\r\n * See {@link ARIA.getFactory}.\r\n *\r\n * @param  {String} attribute\r\n *         Attribute whose factory should be executed.\r\n * @param  {...?} [arguments]\r\n *         Optional parameters to pass to the factory.\r\n * @return {?}\r\n *         Result of executing the factory.\r\n * @throws {ReferenceError}\r\n *         There must be a factory for the given attribute.\r\n */\r\nARIA.runFactory = function (attribute) {\r\n\r\n    var factory = ARIA.getFactory(attribute);\r\n\r\n    if (!factory) {\r\n        throw new ReferenceError(attribute + \" is not a recognised factory\");\r\n    }\r\n\r\n    return factory.apply(undefined, slice(arguments, 1));\r\n\r\n};\r\n\r\n/**\r\n * Creates an alias of WAI-ARIA attributes.\r\n *\r\n * @param  {String} source\r\n *         Source attribute for the alias.\r\n * @param  {Array.<String>|String} aliases\r\n *         Either a single alias or an array of aliases.\r\n * @throws {ReferenceError}\r\n *         The source attribute must have a related factory.\r\n */\r\nARIA.addAlias = function (source, aliases) {\r\n\r\n    var normalSource = ARIA.normalise(source).slice(5);\r\n\r\n    if (!Array.isArray(aliases)) {\r\n        aliases = [aliases];\r\n    }\r\n\r\n    if (!ARIA.getFactory(normalSource)) {\r\n\r\n        throw new ReferenceError(\r\n            \"ARIA.factories.\"\r\n            + normalSource\r\n            + \" does not exist\"\r\n        );\r\n\r\n    }\r\n\r\n    aliases.forEach(function (alias) {\r\n\r\n        var normalAlias = ARIA.normalise(alias).slice(5);\r\n\r\n        ARIA.translate[normalAlias] = normalSource;\r\n        ARIA.factories[normalAlias] = ARIA.factories[normalSource];\r\n\r\n    });\r\n\r\n};\r\n\r\nglobalVariable.ARIA = ARIA;\r\n\r\n/**\r\n * Normalises an attribute name so that it is in lowercase and always starts\r\n * with \"aria-\". This function has the alias of {@link ARIA.normalize} and\r\n * changing one will update the other.\r\n *\r\n * @memberof ARIA\r\n * @param    {String} attribute\r\n *           Attribute to normalise.\r\n * @return   {String}\r\n *           Normalised attribute.\r\n *\r\n * @example\r\n * ARIA.normalise(\"aria-busy\"); // -> \"aria-busy\"\r\n * ARIA.normalise(\"busy\"); // -> \"aria-busy\"\r\n * ARIA.normalise(\"  busy  \"); // -> \"aria-busy\"\r\n * ARIA.normalise(\"BUSY\"); // -> \"aria-busy\"\r\n */\r\nvar normalise = function (attribute) {\r\n\r\n    var string = String(attribute)\r\n        .toLowerCase()\r\n        .replace(/^\\s*(?:aria\\-)?|\\s*$/g, \"\");\r\n    var normal = \"aria-\" + string;\r\n\r\n    return ARIA.translate[normal] || normal;\r\n\r\n};\r\n\r\nvar normaliseDescriptor = {\r\n\r\n    configurable: false,\r\n    enumerable: true,\r\n\r\n    get: function () {\r\n        return normalise;\r\n    },\r\n\r\n    set: function (normaliser) {\r\n        normalise = normaliser;\r\n    }\r\n\r\n};\r\n\r\nObject.defineProperties(ARIA, {\r\n\r\n    normalise: normaliseDescriptor,\r\n\r\n    /**\r\n     * An alias of {@link ARIA.normalise}.\r\n     *\r\n     * @memberof ARIA\r\n     * @function\r\n     */\r\n    normalize: normaliseDescriptor\r\n\r\n});\r\n\r\n/**\r\n * Adds one or more methods to the class.\r\n *\r\n * @memberof Class\r\n * @name     addMethod\r\n * @static\r\n * @param    {Object|String} name\r\n *           Either the name of the method to add or an object of names to\r\n *           methods.\r\n * @param    {Function} [method]\r\n *           Method to add to the class.\r\n */\r\nfunction addClassMethods(name, method) {\r\n\r\n    var parent = this.parent;\r\n\r\n    if (typeof name === \"object\") {\r\n\r\n        Object.keys(name).forEach(function (key) {\r\n            addClassMethods.call(this, key, name[key]);\r\n        }, this);\r\n\r\n    } else {\r\n\r\n        this.prototype[name] = (\r\n            (\r\n                typeof method === \"function\"\r\n                && typeof parent[name] === \"function\"\r\n                && fnTest.test(method)\r\n            )\r\n            ? function () {\r\n\r\n                var hasSuper = \"$super\" in this;\r\n                var temp = this.$super;\r\n                var returnValue = null;\r\n\r\n                this.$super = parent[name];\r\n                returnValue = method.apply(this, arguments);\r\n\r\n                if (hasSuper) {\r\n                    this.$super = temp;\r\n                } else {\r\n                    delete this.$super;\r\n                }\r\n\r\n                return returnValue;\r\n\r\n            }\r\n            : method\r\n        );\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Creates a Class.\r\n *\r\n * @param  {Class} [Base]\r\n *         Optional parent class.\r\n * @param  {Object} proto\r\n *         Methods to add to the created Class' prototype.\r\n * @return {Class}\r\n *         Class created.\r\n */\r\nARIA.createClass = function (Base, proto) {\r\n\r\n    function Class() {\r\n        return this.init.apply(this, arguments);\r\n    }\r\n\r\n    if (!proto) {\r\n\r\n        proto = Base;\r\n        Base = Object;\r\n\r\n    }\r\n\r\n    Class.addMethod = addClassMethods;\r\n\r\n    /**\r\n     * Alias of {@link Class.addMethod}\r\n     */\r\n    Class.addMethods = addClassMethods;\r\n\r\n    /**\r\n     * Reference to the prototype of the Class' super-class.\r\n     * @type {Object}\r\n     */\r\n    Class.parent = Base.prototype;\r\n\r\n    Class.prototype = Object.create(Base.prototype);\r\n    addClassMethods.call(Class, proto);\r\n\r\n    Class.prototype.constructor = Class;\r\n\r\n    if (typeof Class.prototype.init !== \"function\") {\r\n        Class.prototype.init = noop;\r\n    }\r\n\r\n    return Class;\r\n\r\n};\r\n\r\n/**\r\n * A wrapper for setting an attribute on an element. This allows the method to\r\n * be easily replaced for virtual DOMs.\r\n *\r\n * @param {Element} element\r\n *        Element whose attribute should be set.\r\n * @param {String} name\r\n *        Name of the attribute to set.\r\n * @param {String} value\r\n *        Value of the attribute.\r\n */\r\nARIA.setAttribute = function (element, name, value) {\r\n    element.setAttribute(name, value);\r\n};\r\n\r\n/**\r\n * A wrapper for getting an attribute of an element. THis allows the method to\r\n * be easily replaced for virtual DOMs.\r\n *\r\n * @param  {Element} element\r\n *         Element whose attribute should be retrieved.\r\n * @param  {String} name\r\n *         Name of the attribute to retrieve.\r\n * @return {String|null}\r\n *         The value of the attribute or null if that attribute does not exist.\r\n */\r\nARIA.getAttribute = function (element, name) {\r\n    return element.getAttribute(name);\r\n};\r\n\r\n/**\r\n * A wrapper for checking for an attribute on an element. THis allows the method\r\n * to be easily replaced for virtual DOMs.\r\n *\r\n * @param  {Element} element\r\n *         Element whose attribute should be checked.\r\n * @param  {String} name\r\n *         Name of the attribute to check.\r\n * @return {Boolean}\r\n *         true if the element has the given attribute, false otherwise.\r\n */\r\nARIA.hasAttribute = function (element, name) {\r\n    return element.hasAttribute(name);\r\n};\r\n\r\n/**\r\n * A wrapper for removing an attribute from an element. THis allows the method\r\n * to be easily replaced for virtual DOMs.\r\n *\r\n * @param {Element} element\r\n *        Element whose attribute should be removed.\r\n * @param {String} name\r\n *        Name of the attribute to remove.\r\n */\r\nARIA.removeAttribute = function (element, name) {\r\n    element.removeAttribute(name);\r\n};\r\n\r\n/**\r\n * Checks to see if the given element matches the given selector, returning\r\n * true if it does.\r\n *\r\n * @function\r\n * @param    {Element} element\r\n *           Element to test.\r\n * @param    {String} selector\r\n *           CSS selector to check against.\r\n * @return   {Boolean}\r\n *           true if the element matches the given selector, false otherwise.\r\n */\r\nARIA.is = (\r\n    Element.prototype.matches\r\n    ? function (element, selector) {\r\n        return element.matches(selector);\r\n    }\r\n    : (\r\n        Element.prototype.msMatchesSelector\r\n        ? function (element, selector) {\r\n            return element.msMatchesSelector(selector);\r\n        }\r\n        : function (element, selector) {\r\n\r\n            var elements = document.querySelectorAll(selector);\r\n            var length = elements.length;\r\n            var isMatch = false;\r\n\r\n            while (length) {\r\n\r\n                length -= 1;\r\n\r\n                if (elements[length] === element) {\r\n\r\n                    isMatch = true;\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return isMatch;\r\n\r\n        }\r\n    )\r\n);\r\n\r\n/**\r\n * Gets an element by the given ID. If the element cannot be found, null is\r\n * returned. This function is just a wrapper for document.getElementById to\r\n * allow the library to be easily modified in case a virtual DOM is being used.\r\n *\r\n * @param  {String} id\r\n *         ID of the element to find.\r\n * @return {Element|null}\r\n *         Element with the given ID or null if the element cannot be found.\r\n */\r\nARIA.getById = function (id) {\r\n    return document.getElementById(id);\r\n};\r\n\r\nvar counter = 0;\r\n\r\n/**\r\n * The default prefix for {@link ARIA.identify}.\r\n * @type {String}\r\n */\r\nARIA.defaultIdentifyPrefix = \"anonymous-element-\";\r\n\r\n/**\r\n * Returns the ID of the given element. If the element does not have an ID, a\r\n * unique one is generated. THe Generated ID is the given prefix and an\r\n * incrementing counter.\r\n * Pro tip: The HTML specs state that element IDs should start with a letter.\r\n *\r\n * @param  {Element} element\r\n *         Element whose ID should be returned.\r\n * @param  {String} [prefix=ARIA.defaultIdentifyPrefix]\r\n *         Prefix for the generated ID.\r\n * @return {String}\r\n *         The ID of the element.\r\n * @see    http://api.prototypejs.org/dom/Element/identify/\r\n */\r\nARIA.identify = function (element, prefix) {\r\n\r\n    var id = ARIA.getAttribute(element, \"id\");\r\n\r\n    if (prefix === undefined) {\r\n        prefix = ARIA.defaultIdentifyPrefix;\r\n    }\r\n\r\n    if (!id) {\r\n\r\n        do {\r\n\r\n            id = prefix + counter;\r\n            counter += 1;\r\n\r\n        } while (ARIA.getById(id));\r\n\r\n        ARIA.setAttribute(element, \"id\", id);\r\n\r\n    }\r\n\r\n    return id;\r\n\r\n};\r\n\r\n/**\r\n * Checks to see if the given value is a Node.\r\n *\r\n * @param  {?} value\r\n *         Value to test.\r\n * @return {Boolean}\r\n *         true if the given value is a Node, false otherwise.\r\n */\r\nARIA.isNode = function (value) {\r\n    return (value instanceof Node);\r\n};\r\n\r\n/**\r\n * A CSS selector identifying all elements that are automatically added into the\r\n * tab order. Elements are checked against this selector in\r\n * {@link ARIA.makeFocusable} and no action is taken on any element that matches\r\n * this selector.\r\n * @type {String}\r\n */\r\nARIA.FOCUSABLE = (\r\n    \"a[href],\" +\r\n    \"button,\" +\r\n    \"iframe,\" +\r\n    \"input,\" +\r\n    \"select,\" +\r\n    \"textarea,\" +\r\n    \"[tabindex],\" +\r\n    \"[contentEditable=\\\"true\\\"]\"\r\n);\r\n\r\n/**\r\n * Makes an element focusable. This is done by added a tabindex to the element\r\n * which can be optionally defined. If defined, the tabindex must be an integer\r\n * of -1 or at least 0 and less than 32767. If the given element would normally\r\n * be focusable (it matches {@link ARIA.FOCUSABLE}) then no action is taken\r\n * unless the forceTabindex flag is passed.\r\n *\r\n * Be aware that this function doesn't check to see if other factors would\r\n * prevent the element gaining focus, such as it being disabled or hidden (or\r\n * having a disabled or hidden parent). As such, it is possible that the element\r\n * won't be focusable even after this function has run.\r\n *\r\n * @param {Element} element\r\n *        Element that should become focusable.\r\n * @param {Number|String} [tabindex=-1]\r\n *        Optional tab index that will be added to the element to make it\r\n *        focusable. The default is -1 meaning that the element will be\r\n *        focusable but not part of the tab order.\r\n * @param {Boolean} [forceTabindex=false]\r\n *        If set to true then the element will gain the tabindex attribute even\r\n *        if it matches {@link ARIA.FOCUSABLE}.\r\n */\r\nARIA.makeFocusable = function (element, tabindex, forceTabindex) {\r\n\r\n    if (!ARIA.is(element, ARIA.FOCUSABLE) || forceTabindex) {\r\n\r\n        if (tabindex === undefined) {\r\n            tabindex = -1;\r\n        } else if (tabindex !== -1 && tabindex !== \"-1\") {\r\n            tabindex = Math.floor(Math.max(0, Math.min(32766, tabindex)));\r\n        }\r\n\r\n        if (!isNaN(tabindex)) {\r\n            ARIA.setAttribute(element, \"tabindex\", tabindex);\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Resets the focusable state of the element by removing the tabindex element.\r\n *\r\n * Be aware that this doesn't prevent an element becoming focusable, it merely\r\n * resets the focusability to the element's default. Also be aware that this\r\n * function is not limited to only affect elements modified by\r\n * {@link ARIA.makeFocusable} - any element with a tabindex will be modified.\r\n *\r\n * @param {Element} element\r\n *        Element whose focusability should be reset.\r\n */\r\nARIA.resetFocusable = function (element) {\r\n    ARIA.removeAttribute(element, \"tabindex\");\r\n};\r\n\r\n/**\r\n * A warning message for invalid tokens.\r\n * @type {String}\r\n */\r\nARIA.WARNING_INVALID_TOKEN = \"'{0}' is not a valid token for the '{1}' attribtue\";\r\n\r\n/**\r\n * Replaces the placeholders in the string parameter with information from the\r\n * info parameter. Placeholders are wrapped in brackets e.g. \"{0}\".\r\n *\r\n * @param  {String} string\r\n *         String containing placeholders.\r\n * @param  {Array|Object} info\r\n *         Info to fill the string placeholders.\r\n * @return {String}\r\n *         Populated string.\r\n */\r\nARIA.supplant = function (string, info) {\r\n\r\n    return string.replace(/\\{(\\d+)\\}/g, function (whole, index) {\r\n\r\n        var arg = info[index];\r\n\r\n        return (\r\n            (typeof arg === \"string\" || typeof arg === \"number\")\r\n            ? arg\r\n            : whole\r\n        );\r\n\r\n    })\r\n\r\n};\r\n\r\n/**\r\n * A flag to enable warnings.\r\n * @type {Boolean}\r\n */\r\nARIA.enableWarnings = true;\r\n\r\n/**\r\n * Sends a warning.\r\n *\r\n * @param {String} message\r\n *        Message (and placeholders).\r\n * @param {Number|String} ...arguments\r\n *        Information to populate the message.\r\n */\r\nARIA.warn = function (message) {\r\n\r\n    if (ARIA.enableWarnings) {\r\n        console.warn(\"aria.js: \" + ARIA.supplant(message, slice(arguments, 1)));\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Handles basic WAI-ARIA properties.\r\n *\r\n * @class ARIA.Property\r\n */\r\nARIA.Property = ARIA.createClass(/** @lends ARIA.Property.prototype */{\r\n\r\n    /**\r\n     * @constructs ARIA.Property\r\n     * @param      {Element} element\r\n     *             Element whose attribute should be handled.\r\n     * @param      {String} attribute\r\n     *             Name of the attribute to handle.\r\n     * @param      {Array.<String>} [tokens]\r\n     *             Optional white-list of valid tokens for this property.\r\n     */\r\n    init: function (element, attribute, tokens) {\r\n\r\n        /**\r\n         * Element whose attribute is being handled.\r\n         * @type {Element}\r\n         */\r\n        this.element = element;\r\n\r\n        /**\r\n         * Attribute being handled.\r\n         * @type {String}\r\n         */\r\n        this.attribute = attribute;\r\n\r\n        /**\r\n         * White-list of valid tokens.\r\n         * @type {Array.<String>}\r\n         */\r\n        this.tokens = (\r\n            (tokens && Array.isArray(tokens))\r\n            ? tokens\r\n            : []\r\n        );\r\n\r\n        // Things like ARIA.List work with interpretted values rather than just\r\n        // the attribute value. If the attribute already exists, pass the value\r\n        // to the set method to allow for that. As a bonus, this can filter out\r\n        // invalid attribute values.\r\n        if (ARIA.hasAttribute(element, attribute)) {\r\n            this.set(ARIA.getAttribute(element, attribute));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Interprets the given value so it can be set.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {String}\r\n     *         String based on the value.\r\n     */\r\n    interpret: function (value) {\r\n        return ARIA.Property.interpret(value);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the given token is valid for this current property. This\r\n     * function checks against {@link ARIA.Property#tokens}. If the token is not\r\n     * valid, a warning it sent. See {@link ARIA.warn}.\r\n     *\r\n     * @param  {String} token\r\n     *         Token to check.\r\n     * @return {Boolean}\r\n     *         true if the token is valid, false otherwise.\r\n     */\r\n    isValidToken: function (token) {\r\n\r\n        var isValid = (!this.tokens.length || this.tokens.indexOf(token) > -1);\r\n\r\n        if (!isValid) {\r\n            ARIA.warn(ARIA.WARNING_INVALID_TOKEN, token, this.attribute);\r\n        }\r\n\r\n        return isValid;\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the value of {@link ARIA.Property#attribute} and interprets it\r\n     * (see {@link ARIA.Property#interpret}). If {@link ARIA.Property#element}\r\n     * doesn't have {@link ARIA.Property#attribute} then null is returned.\r\n     *\r\n     * @return {String|null}\r\n     *         Interpretted value of {@link ARIA.Property#attribute} or null if\r\n     *         the attribute is not set.\r\n     */\r\n    get: function () {\r\n\r\n        var element = this.element;\r\n        var attribute = this.attribute;\r\n\r\n        return (\r\n            ARIA.hasAttribute(element, attribute)\r\n            ? this.interpret(ARIA.getAttribute(element, attribute))\r\n            : null\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets {@link ARIA.Property#attribute} to the given value, once\r\n     * interpretted (see {@link ARIA.Property#interpret}) and validated (see\r\n     * {@link ARIA.Property#isValidToken}). If the value is interpretted as an\r\n     * empty string, the attribute is removed.\r\n     *\r\n     * @param {?} value\r\n     *        Value to set.\r\n     */\r\n    set: function (value) {\r\n\r\n        var element = this.element;\r\n        var attribute = this.attribute;\r\n        var interpretted = this.interpret(value);\r\n\r\n        if (interpretted !== \"\" && this.isValidToken(interpretted)) {\r\n            ARIA.setAttribute(element, attribute, interpretted);\r\n        } else if (interpretted === \"\") {\r\n            ARIA.removeAttribute(element, attribute);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of {@link ARIA.Property#attribute} as a string. See\r\n     * {@link ARIA.Property#get}.\r\n     *\r\n     * @return {String}\r\n     *         Value of the attribute.\r\n     */\r\n    toString: function () {\r\n        return ARIA.getAttribute(this.element, this.attribute) || \"\";\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Interprets the given value so it can be set. This is used to power\r\n * {@link ARIA.Property#interpret} while also being exposed so other functions\r\n * and classes can use it.\r\n *\r\n * @param  {?} value\r\n *         Value to interpret.\r\n * @return {String}\r\n *         String based on the value.\r\n */\r\nARIA.Property.interpret = function (value) {\r\n\r\n    return (\r\n        (value === null || value === undefined)\r\n        ? \"\"\r\n        : String(value).trim()\r\n    );\r\n\r\n};\r\n\r\n/**\r\n * Handles number values.\r\n *\r\n * @class ARIA.Integer\r\n * @extends ARIA.Property\r\n */\r\nARIA.Number = ARIA.createClass(ARIA.Property, /** @lends ARIA.Number.prototype */{\r\n\r\n    /**\r\n     * Interprets the value as a number. If the value can't be converted into a\r\n     * number, NaN is returned.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Number}\r\n     *         Number value.\r\n     */\r\n    interpret: function (value) {\r\n        return parseFloat(this.$super(value));\r\n    },\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    isValidToken: function (value) {\r\n\r\n        var isValid = !isNaN(this.interpret(value));\r\n\r\n        if (!isValid) {\r\n            ARIA.warn(ARIA.WARNING_INVALID_TOKEN, value, this.attribute);\r\n        }\r\n\r\n        return isValid;\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles number values.\r\n *\r\n * @class ARIA.Integer\r\n * @extends ARIA.Number\r\n */\r\nARIA.Integer = ARIA.createClass(ARIA.Number, /** @lends ARIA.Integer.prototype */{\r\n\r\n    /**\r\n     * Interprets the value as an integer. If the value can't be converted into\r\n     * a number, NaN is returned.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Number}\r\n     *         Number value.\r\n     */\r\n    interpret: function (value) {\r\n        return Math.floor(this.$super(value));\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles WAI-ARIA states.\r\n *\r\n * @class ARIA.State\r\n * @extends ARIA.Property\r\n */\r\nARIA.State = ARIA.createClass(ARIA.Property, /** @lends ARIA.State.prototype */{\r\n\r\n    /**\r\n     * Unlike the parent {@link ARIA.Property}, an instance of ARIA.State cannot\r\n     * have tokens set.\r\n     *\r\n     * @constructs ARIA.State\r\n     * @param      {Element} element\r\n     *             Element whose attribute should be handled.\r\n     * @param      {String} attribute\r\n     *             Name of the attribute to handle.\r\n     */\r\n    init: function (element, attribute) {\r\n\r\n        this.$super(element, attribute, [\r\n            \"true\",\r\n            \"false\"\r\n        ]);\r\n\r\n    },\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    isValidToken: function (token) {\r\n        return typeof token === \"boolean\" || this.$super(token);\r\n    },\r\n\r\n    /**\r\n     * Coerces the given value into a boolean.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to coerce.\r\n     * @return {Boolean|String}\r\n     *         Coerced boolean or an empty string.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        var interpretted = this.$super(value);\r\n        var isTrue = interpretted === \"true\";\r\n\r\n        return (\r\n            (isTrue || interpretted === \"false\")\r\n            ? isTrue\r\n            : interpretted\r\n        );\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles a WAI-ARIA state that can be true or false but can also be undefined.\r\n *\r\n * @class ARIA.UndefinedState\r\n * @extends ARIA.State\r\n */\r\nARIA.UndefinedState = ARIA.createClass(ARIA.State, /** @lends ARIA.UndefinedState.prototype */{\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    init: function (element, attribute) {\r\n\r\n        this.$super(element, attribute);\r\n        this.tokens.push(\"undefined\");\r\n\r\n    },\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    isValidToken: function (token) {\r\n        return token === undefined || this.$super(token);\r\n    },\r\n\r\n    /**\r\n     * Interprets undefined as \"undefined.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Boolean|String}\r\n     *         Either the boolean value, \"undefined\" or an empty string if the\r\n     *         value is not understood.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        return (\r\n            (value === undefined || value === \"undefined\")\r\n            ? \"undefined\"\r\n            : this.$super(value)\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean or undefined.\r\n     *\r\n     * @return {Boolean|undefined}\r\n     *         Value of the attribute.\r\n     */\r\n    get: function () {\r\n\r\n        var value = this.$super();\r\n\r\n        if (value === \"undefined\") {\r\n            value = undefined;\r\n        }\r\n\r\n        return value;\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles WAI-ARIA tristates. That is, a state that can be either true, false\r\n * or \"mixed\".\r\n *\r\n * @class ARIA.Tristate\r\n * @extends ARIA.State\r\n */\r\nARIA.Tristate = ARIA.createClass(ARIA.State, /** @lends ARIA.Tristate.prototype */{\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    init: function (element, attribute) {\r\n\r\n        this.$super(element, attribute);\r\n        this.tokens.push(\"mixed\");\r\n\r\n    },\r\n\r\n    /**\r\n     * Allows the token \"mixed\".\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Boolean|String}\r\n     *         Either the boolean value, \"mixed\" or an empty string if the value\r\n     *         is not understood.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        return (\r\n            value === \"mixed\"\r\n            ? value\r\n            : this.$super(value)\r\n        );\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles a WAI-ARIA attribute that should be a space-separated list.\r\n *\r\n * @class ARIA.List\r\n * @extends ARIA.Property\r\n */\r\nARIA.List = ARIA.createClass(ARIA.Property, /** ARIA.List.prototype */{\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    init: function (element, attribute, tokens) {\r\n\r\n        /**\r\n         * The list of values.\r\n         * @type {Array.<String>}\r\n         */\r\n        this.list = [];\r\n\r\n        this.$super(element, attribute, tokens);\r\n\r\n    },\r\n\r\n    /**\r\n     * Coerces the values into a string and splits it at the spaces.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Array.<String>}\r\n     *         Array of strings.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        var val = (\r\n            Array.isArray(value)\r\n            ? value.join(\" \")\r\n            : value\r\n        );\r\n        var string = this.$super(val);\r\n\r\n        return (\r\n            string.length\r\n            ? string.split(/\\s+/)\r\n            : []\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the value of the list to be the given value. The values are\r\n     * interpretted as an array (see {@link ARIA.List#interpret} and validated\r\n     * (see {@link ARIA.List#isValidToken}); only unique values are added.\r\n     *\r\n     * @param {?} value\r\n     *        Value(s) to add. If the given value is a string, it is assumed to\r\n     *        be a space-separated list.\r\n     */\r\n    set: function (value) {\r\n\r\n        var that = this;\r\n        var values = that.interpret(value).reduce(function (unique, token) {\r\n\r\n            if (\r\n                token\r\n                && that.isValidToken(token)\r\n                && unique.indexOf(token) < 0\r\n            ) {\r\n                unique.push(token);\r\n            }\r\n\r\n            return unique;\r\n\r\n        }, []);\r\n        var element = that.element;\r\n        var attribute = that.attribute;\r\n\r\n        that.list = values;\r\n\r\n        if (values.length) {\r\n            ARIA.setAttribute(element, attribute, values.join(\" \"));\r\n        } else {\r\n            ARIA.removeAttribute(element, attribute);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the value of the attribute as an array.\r\n     *\r\n     * @return {Array.<String>}\r\n     *         Value of the attribute as an array.\r\n     */\r\n    get: function () {\r\n        return this.list.concat();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles WAI-ARIA attributes that reference a single ID.\r\n *\r\n * @class ARIA.Reference\r\n * @extends ARIA.Property\r\n */\r\nARIA.Reference = ARIA.createClass(ARIA.Property, /** @lends ARIA.Reference.prototype */{\r\n\r\n    /**\r\n     * Interprets the given value as a string. If the value is an element, the\r\n     * element's ID is returned, generating one if necessary - see\r\n     * {@link ARIA.identify}.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {String}\r\n     *         The interpretted value.\r\n     */\r\n    interpret: function (value) {\r\n        return ARIA.Reference.interpret(value);\r\n    },\r\n\r\n    /**\r\n     * Gets the element referenced by this attribute. If the element cannot be\r\n     * found or the attribute isn't set, null is returned.\r\n     *\r\n     * @return {Element|null}\r\n     *         Element referenced by this attribute or null if the element\r\n     *         cannot be found or the attribute isn't set.\r\n     */\r\n    get: function () {\r\n        return ARIA.getById(this.$super());\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Interprets the given value as a string. If the value is an element, the\r\n * element's ID is returned, generating one if necessary = see\r\n * {@link ARIA.identify}. This powers {@link ARIA.Reference#interpret} while\r\n * also allowing other functions and classes to use it.\r\n *\r\n * @param  {?} value\r\n *         Value to interpret.\r\n * @return {String}\r\n *         The interpretted value.\r\n */\r\nARIA.Reference.interpret = function (value) {\r\n\r\n    return (\r\n        ARIA.isNode(value)\r\n        ? ARIA.identify(value)\r\n        : ARIA.Property.interpret(value)\r\n    );\r\n\r\n};\r\n\r\n/**\r\n * Handles WAI-ARIA attributes that handle space-separated lists of IDs.\r\n * @class ARIA.ReferenceList\r\n * @extends ARIA.List\r\n */\r\nARIA.ReferenceList = ARIA.createClass(ARIA.List, /** @lends ARIA.ReferenceList.prototype */{\r\n\r\n    /**\r\n     * Interprets an element, ID or array of elements or/and IDs as an array of\r\n     * element IDs.\r\n     *\r\n     * @param  {Array.<Element|String>|Element|String} value\r\n     *         Value(s) to interpret.\r\n     * @return {Array.<String>}\r\n     *         Collection of IDs.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        var interpretted = [];\r\n\r\n        if (\r\n            value\r\n            && typeof value === \"object\"\r\n            && typeof value.length === \"number\"\r\n        ) {\r\n            interpretted = arrayFrom(value, ARIA.Reference.interpret, this);\r\n        } else if (typeof value === \"string\") {\r\n            interpretted = this.$super(value);\r\n        } else {\r\n            interpretted = [ARIA.Reference.interpret(value)];\r\n        }\r\n\r\n        // Remove all falsy values such as \"\" or null.\r\n        return interpretted.filter(Boolean);\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets an array of elements referenced by the attribute. If the element\r\n     * cannot be found, null will be in place of the element.\r\n     *\r\n     * @return {Array.<Element|null>}\r\n     *         Array of elements.\r\n     */\r\n    get: function () {\r\n        return this.$super().map(ARIA.getById);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles the WAI-ARIA attributes on an element.\r\n *\r\n * @class ARIA.Element\r\n */\r\nARIA.Element = ARIA.createClass(/** @lends ARIA.ELement.prototype */{\r\n\r\n    /**\r\n     * @constructs ARIA.Element\r\n     * @param      {Element} element\r\n     *             Element whose WAI-ARIA attributes should be handled.\r\n     */\r\n    init: function (element) {\r\n\r\n        /**\r\n         * Element whose WAI-ARIA attributes should be handled.\r\n         * @type {Element}\r\n         */\r\n        this.element = element;\r\n\r\n        /**\r\n         * A flag object that keeps track of attributes being modified. Prevents\r\n         * infinitely loops being caused in the MutationObserver.\r\n         * @type {Object}\r\n         */\r\n        this.manipulationFlags = Object.create(null);\r\n\r\n        this.preloadAttributes();\r\n        this.readAttributes();\r\n        this.observeAttributes();\r\n\r\n    },\r\n\r\n    /**\r\n     * Creates placeholders for all the WAI-ARIA attributes that are in\r\n     * {@link ARIA.factories}. The factories are lazy-loaded so they're only\r\n     * instantiated as needed.\r\n     */\r\n    preloadAttributes: function () {\r\n\r\n        Object.keys(ARIA.factories).forEach(function (attribute) {\r\n\r\n            var instance;\r\n            var element = this.element;\r\n\r\n            function createValue() {\r\n\r\n                instance = ARIA.runFactory(attribute, element);\r\n                // instance.get(element)[attribute] = instance;\r\n\r\n                return instance;\r\n\r\n            }\r\n\r\n            Object.defineProperty(this, attribute, {\r\n\r\n                configurable: true,\r\n\r\n                get: function () {\r\n\r\n                    var inst = instance || createValue();\r\n\r\n                    return inst.get();\r\n\r\n                },\r\n\r\n                set: function (value) {\r\n\r\n                    var inst = instance || createValue();\r\n\r\n                    return inst.set(value);\r\n\r\n                }\r\n\r\n            });\r\n\r\n        }, this);\r\n\r\n\r\n    },\r\n\r\n    /**\r\n     * Reads all the WAI-ARIA attributes on {@link ARIA.Element#element} and\r\n     * sets the {@link ARIA.Property} values.\r\n     */\r\n    readAttributes: function () {\r\n\r\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n        arrayFrom(this.element.attributes, function (attribute) {\r\n\r\n            var name = attribute.name.replace(/^aria\\-/, \"\");\r\n\r\n            if (hasOwnProperty.call(this, name)) {\r\n                this[name] = attribute.value;\r\n            }\r\n\r\n        }, this);\r\n\r\n    },\r\n\r\n    /**\r\n     * Creates the observer {@link ARIA.Element#observer} that listens for\r\n     * changes to WAI-ARIA attribtues and updates the {@link ARIA.Property}\r\n     * values.\r\n     */\r\n    observeAttributes: function () {\r\n\r\n        var that = this;\r\n        var element = that.element;\r\n        var observer = new MutationObserver(function (mutations) {\r\n\r\n            mutations.forEach(function (mutation) {\r\n\r\n                var attribute = mutation.attributeName || \"\";\r\n                var suffix = attribute.slice(5);\r\n                var value;\r\n                var old;\r\n\r\n                if (\r\n                    mutation.type === \"attributes\"\r\n                    && ARIA.factories[suffix]\r\n                    && !that.manipulationFlags[suffix]\r\n                ) {\r\n\r\n                    that.manipulationFlags[suffix] = true;\r\n\r\n                    if (ARIA.hasAttribute(element, attribute)) {\r\n\r\n                        value = ARIA.Property.interpret(\r\n                            ARIA.getAttribute(element, attribute)\r\n                        );\r\n                        old = ARIA.Property.interpret(mutation.oldValue);\r\n\r\n                        if (value !== old) {\r\n                            that[suffix] = value;\r\n                        }\r\n\r\n                    } else {\r\n                        that[suffix] = \"\";\r\n                    }\r\n\r\n                    window.setTimeout(function () {\r\n                        delete that.manipulationFlags[suffix];\r\n                    }, 0);\r\n\r\n                }\r\n\r\n            });\r\n\r\n        });\r\n\r\n        observer.observe(element, {\r\n            attributes: true,\r\n            attributeOldValue: true\r\n        });\r\n\r\n        /**\r\n         * The observer.\r\n         * @type {MutationObserver}\r\n         */\r\n        that.observer = observer;\r\n\r\n    },\r\n\r\n    /**\r\n     * Disconnects {@link ARIA.Element#observer}.\r\n     */\r\n    disconnectAttributes: function () {\r\n        this.observer.disconnect();\r\n    }\r\n\r\n});\r\n\r\n/*\r\nARIA.Element.prototype.init = function (element) {\r\n    this.element = element;\r\n};\r\n\r\nARIA.Element.prototype.preloadAttributes = function () {};\r\n\r\nARIA.ELement.prototype = new Proxy(ARIA.Element.prototype, {\r\n\r\n    get: function (target, name) {\r\n    },\r\n\r\n    set: function (target, name, value) {\r\n    },\r\n\r\n    deleteProperty: function (target, name) {\r\n    }\r\n\r\n});\r\n*/\r\n\r\nvar factoryEntries = [\r\n    [ARIA.Property, [\r\n        \"autocomplete\",\r\n        \"current\",\r\n        \"haspopup\",\r\n        \"invalid\",\r\n        \"keyshortcuts\",\r\n        \"label\",\r\n        \"live\",\r\n        \"orientation\",\r\n        \"placeholder\",\r\n        \"roledescription\",\r\n        \"sort\",\r\n        \"valuetext\"\r\n    ]],\r\n    [ARIA.Reference, [\r\n        \"activedescendant\",\r\n        \"details\",\r\n        \"errormessage\"\r\n    ]],\r\n    [ARIA.ReferenceList, [\r\n        \"controls\",\r\n        \"describedby\",\r\n        \"flowto\",\r\n        \"labelledby\",\r\n        \"owns\"\r\n    ]],\r\n    [ARIA.State, [\r\n        \"atomic\",\r\n        \"busy\",\r\n        \"disabled\",\r\n        \"modal\",\r\n        \"multiline\",\r\n        \"multiselectable\",\r\n        \"readonly\",\r\n        \"required\"\r\n    ]],\r\n    [ARIA.Tristate, [\r\n        \"checked\",\r\n        \"pressed\"\r\n    ]],\r\n    [ARIA.UndefinedState, [\r\n        \"expanded\",\r\n        \"grabbed\",\r\n        \"hidden\",\r\n        \"selected\"\r\n    ]],\r\n    [ARIA.Integer, [\r\n        \"colcount\",\r\n        \"colindex\",\r\n        \"colspan\",\r\n        \"level\",\r\n        \"posinset\",\r\n        \"rowcount\",\r\n        \"rowindex\",\r\n        \"rowspan\",\r\n        \"setsize\"\r\n    ]],\r\n    [ARIA.Number, [\r\n        \"valuemax\",\r\n        \"valuemin\",\r\n        \"valuenow\"\r\n    ]],\r\n    [ARIA.List, [\r\n        \"dropeffect\",\r\n        \"relevant\"\r\n    ]]\r\n];\r\n\r\nfactoryEntries.forEach(function (entry) {\r\n\r\n    entry[1].forEach(function (attribute) {\r\n\r\n        var normal = ARIA.normalise(attribute);\r\n\r\n        ARIA.factories[attribute] = function (element) {\r\n\r\n            var instance;\r\n            var tokens = ARIA.tokens[normal];\r\n\r\n            if (!tokens) {\r\n\r\n                tokens = [];\r\n                ARIA.tokens[normal] = tokens;\r\n\r\n            }\r\n\r\n            instance = new entry[0](element, normal, tokens);\r\n\r\n            return instance;\r\n\r\n        };\r\n\r\n    });\r\n\r\n});\r\n\r\nARIA.addAlias(\"labelledby\", \"labeledby\");\r\n}(window));"],"file":"aria.min.js"}