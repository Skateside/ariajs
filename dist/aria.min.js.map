{"version":3,"sources":["aria.js"],"names":["globalVariable","identity","x","slice","arrayLike","offset","Array","prototype","call","arrayFrom","from","map","context","undefined","objectAssign","Object","assign","source","arguments","forEach","object","keys","key","noop","fnTest","test","isNotANumber","Number","isNaN","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setTimeout","ARIA","tokens","create","aria-autocomplete","aria-current","aria-dropeffect","aria-haspopup","aria-invalid","aria-live","aria-orientation","aria-relevant","aria-sort","role","defineProperty","configurable","enumerable","writable","value","previousAria","getPrevious","restorePrevious","extendDOM","aria","translate","aria-role","aria-tabindex","normalise","attribute","normal","String","toLowerCase","replace","normaliseDescriptor","get","set","normaliser","addClassMethods","name","method","parent","this","returnValue","hasSuper","temp","$super","apply","defineProperties","normalize","suffixMap","getSuffix","mapped","createClass","Base","proto","Class","init","addMethod","addMethods","constructor","setAttribute","element","getAttribute","hasAttribute","removeAttribute","getById","id","document","getElementById","counter","defaultIdentifyPrefix","identify","prefix","isNode","Node","WARNING_INVALID_TOKEN","supplant","string","info","whole","index","arg","enableWarnings","warn","message","console","Property","isArray","interpret","isValidToken","token","isValid","length","indexOf","interpretted","toString","trim","parseFloat","min","max","Integer","Math","floor","State","isTrue","UndefinedState","push","Tristate","List","list","val","join","split","that","values","reduce","unique","concat","Reference","ReferenceList","filter","Boolean","Element","instances","readAttributes","observeAttributes","activateTraps","getInstance","instance","getFactory","runFactory","attributes","observer","makeObserver","data","factories","suffix","disconnectAttributes","disconnect","Proxy","target","deleteProperty","checker","setter","unsetter","manipulationFlags","MutationObserver","mutations","mutation","attributeName","type","old","oldValue","observe","attributeOldValue","owns","hasOwnProperty","bind","setProperty","isPolling","poll","factory","ReferenceError","makeFactory","Constructor","entry","addAlias","aliases","normalSource","alias","normalAlias","ariaProp","roleProp","nodeProto","getString","property","Error","getter","window"],"mappings":"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","sourcesContent":["/*! ariajs - v0.2.0 - MIT license - https://github.com/Skateside/ariajs - 2018-11-13 */\n(function (globalVariable) {\n    \"use strict\";\n\n/**\n * A function that returns the given variable unchanged.\n *\n * @private\n * @param   {?} x\n *          Variable to return.\n * @return  {?}\n *          Unmodified original variable.\n */\nvar identity = function (x) {\n    return x;\n};\n\n/**\n * A simple wrapper for Array#slice.\n *\n * @private\n * @param   {Array|Object} arrayLike\n *          Array or array-like structure to slice.\n * @param   {Number} [offset]\n *          Optional offset for the slice.\n * @return  {Array}\n *          Sliced array.\n */\nvar slice = function (arrayLike, offset) {\n    return Array.prototype.slice.call(arrayLike, offset);\n};\n\n/**\n * A simple fall-back for Array.from.\n *\n * @private\n * @param   {Object} arrayLike\n *          Array-like structure.\n * @param   {Function} [map=identity]\n *          Optional function to convert the values.\n * @param   {?} [context]\n *          Optional context for the map function.\n * @return  {Array}\n *          Array made from the iven array-like structure.\n */\nvar arrayFrom = Array.from || function (arrayLike, map, context) {\n\n    if (map === undefined) {\n        map = identity;\n    }\n\n    return Array.prototype.map.call(arrayLike, map, context);\n\n};\n\n/**\n * A simple fall-back for Object.assign.\n *\n * @private\n * @param   {Object} source\n *          Source object to modify.\n * @param   {Object} [...objects]\n *          Additional objects to extend the first.\n * @return  {Object}\n *          Extended object.\n */\nvar objectAssign = Object.assign || function (source) {\n\n    slice(arguments, 1).forEach(function (object) {\n\n        if (object) {\n\n            Object.keys(object).forEach(function (key) {\n                source[key] = object[key];\n            });\n\n        }\n\n    });\n\n    return source;\n\n};\n\n/**\n * A function that does nothing.\n *\n * @private\n */\nvar noop = function () {\n    return;\n};\n\n/**\n * The regular expression used to test functions for whether or not they include\n * the \"$super\" magic property.\n * @private\n * @type    {RegExp}\n */\nvar fnTest = (\n    (/return/).test(noop)\n    ? (/[.'\"]\\$super\\b/)\n    : (/.*/)\n);\n\n/**\n * A basic fallback for the isNaN function.\n *\n * @private\n * @function\n * @param    {?} value\n *           Value to test.\n * @return   {Boolean}\n *           true if the value is NaN, false otherwise.\n */\nvar isNotANumber = Number.isNaN || globalVariable.isNaN;\n\n/**\n * A reference (and possible fallback) for requestAnimationFrame.\n *\n * @private\n * @function\n * @param    {Function} callback\n *           Function to execute when the animation frame ticks over.\n */\nvar requestAnimationFrame = (\n    globalVariable.requestAnimationFrame\n    || globalVariable.webkitRequestAnimationFrame\n    || globalVariable.mozRequestAnimationFrame\n    || function (callback) {\n        globalVariable.setTimeout(callback, 1000 / 60);\n    }\n);\n\n/**\n * @namespace\n */\nvar ARIA = {\n\n    /**\n     * Collection of all valid tokens for any given attribute. The attribute\n     * key should be the normalised value - see {@link ARIA.normalise}.\n     * @type {[type]}\n     */\n    tokens: objectAssign(Object.create(null), {\n        \"aria-autocomplete\": [\n            \"none\",\n            \"inline\",\n            \"list\",\n            \"both\"\n        ],\n        \"aria-current\": [\n            \"false\",\n            \"true\",\n            \"page\",\n            \"step\",\n            \"location\",\n            \"date\",\n            \"time\"\n        ],\n        \"aria-dropeffect\": [\n            \"none\",\n            \"copy\",\n            \"execute\",\n            \"link\",\n            \"move\",\n            \"popup\"\n        ],\n        \"aria-haspopup\": [\n            \"false\",\n            \"true\",\n            \"menu\",\n            \"listbox\",\n            \"tree\",\n            \"grid\",\n            \"dialog\"\n        ],\n        \"aria-invalid\": [\n            \"false\",\n            \"true\",\n            \"grammar\",\n            \"spelling\"\n        ],\n        \"aria-live\": [\n            \"off\",\n            \"assertive\",\n            \"polite\"\n        ],\n        \"aria-orientation\": [\n            undefined,\n            \"undefined\",\n            \"horizontal\",\n            \"vertical\"\n        ],\n        \"aria-relevant\": [\n            \"additions\",\n            \"all\",\n            \"removals\",\n            \"text\"\n        ],\n        \"aria-sort\": [\n            \"none\",\n            \"ascending\",\n            \"descending\",\n            \"other\"\n        ],\n        // \"Authors MUST NOT use abstract roles in content.\"\n        // https://www.w3.org/TR/wai-aria-1.1/#abstract_roles\n        \"role\": [\n            \"alert\",\n            \"alertdialog\",\n            \"application\",\n            \"article\",\n            \"banner\",\n            \"button\",\n            \"cell\",\n            \"checkbox\",\n            \"columnheader\",\n            \"complementary\",\n            \"combobox\",\n            // \"command\", // (abstract)\n            // \"composite\", // (abstract)\n            \"contentinfo\",\n            \"definition\",\n            \"dialog\",\n            \"directory\",\n            \"document\",\n            \"feed\",\n            \"figure\",\n            \"form\",\n            \"grid\",\n            \"gridcell\",\n            \"group\",\n            \"heading\",\n            \"img\",\n            // \"input\", // (abstract)\n            // \"landmark\", // (abstract)\n            \"link\",\n            \"list\",\n            \"listbox\",\n            \"listitem\",\n            \"log\",\n            \"main\",\n            \"marquee\",\n            \"math\",\n            \"menu\",\n            \"menubar\",\n            \"menuitem\",\n            \"menuitemcheckbox\",\n            \"menuitemradio\",\n            \"navigation\",\n            \"none\",\n            \"note\",\n            \"option\",\n            \"presentation\",\n            \"progressbar\",\n            \"radio\",\n            \"radiogroup\",\n            // \"range\", // (abstract)\n            \"region\",\n            // \"roletype\", // (abstract)\n            \"row\",\n            \"rowgroup\",\n            \"rowheader\",\n            \"scrollbar\",\n            \"search\",\n            \"searchbox\",\n            // \"section\", // (abstract)\n            // \"sectionhead\", // (abstract)\n            // \"select\", // (abstract)\n            \"separator\",\n            \"slider\",\n            \"spinbutton\",\n            \"status\",\n            // \"structure\", // (abstract)\n            \"switch\",\n            \"tab\",\n            \"table\",\n            \"tablist\",\n            \"tabpanel\",\n            \"term\",\n            \"textbox\",\n            \"timer\",\n            \"toolbar\",\n            \"tooltip\",\n            \"tree\",\n            \"treegrid\",\n            \"treeitem\"\n            // \"widget\", // (abstract)\n            // \"window\", // (abstract)\n        ]\n    })\n\n};\n\n/**\n * The version of the library.\n *\n * @memberof ARIA\n * @type {String}\n * @constant\n * @name VERSION\n */\nObject.defineProperty(ARIA, \"VERSION\", {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value: \"0.2.0\"\n});\n\nvar previousAria = globalVariable.ARIA;\nglobalVariable.ARIA = ARIA;\n\n/**\n * Returns the previous value of the global ARIA variable.\n *\n * @return {?}\n *         Previous ARIA value.\n */\nARIA.getPrevious = function () {\n    return previousAria;\n};\n\n/**\n * Removes the value of {@link ARIA} from the global variable and sets it back\n * to the previous value. This version of {@link ARIA} is returned.\n *\n * @return {Object}\n *         Current version of {@link ARIA}.\n */\nARIA.restorePrevious = function () {\n\n    globalVariable.ARIA = previousAria;\n\n    return ARIA;\n\n};\n\n/**\n * Name of the property for the {@link ARIA.Element} instance on DOM nodes.\n * @type {String}\n */\nARIA.extendDOM = {\n\n    aria: \"aria\",\n\n    role: \"role\"\n\n};\n\n/**\n * Map of all mis-spellings and aliases. The attribute key should be the\n * normalised value - see {@link ARIA.normalise}.\n * @type {Object}\n */\nARIA.translate = objectAssign(Object.create(null), {\n    \"aria-role\": \"role\",\n    \"aria-tabindex\": \"tabindex\"\n});\n\n/**\n * Normalises an attribute name so that it is in lowercase and always starts\n * with \"aria-\". This function has the alias of {@link ARIA.normalize} and\n * changing one will update the other.\n *\n * @memberof ARIA\n * @name     normalise\n * @param    {String} attribute\n *           Attribute to normalise.\n * @return   {String}\n *           Normalised attribute.\n *\n * @example\n * ARIA.normalise(\"aria-busy\"); // -> \"aria-busy\"\n * ARIA.normalise(\"busy\"); // -> \"aria-busy\"\n * ARIA.normalise(\"  busy  \"); // -> \"aria-busy\"\n * ARIA.normalise(\"BUSY\"); // -> \"aria-busy\"\n */\nvar normalise = function (attribute) {\n\n    var string = String(attribute)\n        .toLowerCase()\n        .replace(/^\\s*(?:aria\\-)?|\\s*$/g, \"\");\n    var normal = \"aria-\" + string;\n\n    return ARIA.translate[normal] || normal;\n\n};\n\nvar normaliseDescriptor = {\n\n    configurable: false,\n    enumerable: true,\n\n    get: function () {\n        return normalise;\n    },\n\n    set: function (normaliser) {\n        normalise = normaliser;\n    }\n\n};\n\nObject.defineProperties(ARIA, {\n\n    normalise: normaliseDescriptor,\n\n    /**\n     * An alias of {@link ARIA.normalise}.\n     *\n     * @memberof ARIA\n     * @function\n     */\n    normalize: normaliseDescriptor\n\n});\n\n/**\n * A map of all conversions for {@link ARIA.getSuffix}. As well as acting like a\n * cache for frequent conversions, this also allows plugins to use un-expected\n * attribute names since the conversion can be added here.\n * @type {Object}\n */\nARIA.suffixMap = Object.create(null);\n\n/**\n * Converts the attribute into the WAI-ARIA suffic (e.g. \"aria-label\" becomes\n * \"label\" etc.).\n *\n * @param  {String} attribute\n *         Attribute whose stemp should be returned.\n * @return {String}\n *         Stem of the attribute.\n */\nARIA.getSuffix = function (attribute) {\n\n    var mapped = ARIA.suffixMap[attribute];\n\n    if (!mapped) {\n\n        mapped = attribute.replace(/^aria\\-/, \"\");\n        ARIA.suffixMap[attribute] = mapped;\n\n    }\n\n    return mapped;\n\n};\n\n/**\n * Adds one or more methods to the class.\n *\n * @memberof Class\n * @name     addMethod\n * @static\n * @param    {Object|String} name\n *           Either the name of the method to add or an object of names to\n *           methods.\n * @param    {Function} [method]\n *           Method to add to the class.\n */\nfunction addClassMethods(name, method) {\n\n    var parent = this.parent;\n\n    if (typeof name === \"object\") {\n\n        Object.keys(name).forEach(function (key) {\n            addClassMethods.call(this, key, name[key]);\n        }, this);\n\n    } else {\n\n        this.prototype[name] = (\n            (\n                typeof method === \"function\"\n                && typeof parent[name] === \"function\"\n                && fnTest.test(method)\n            )\n            ? function () {\n\n                var hasSuper = \"$super\" in this;\n                var temp = this.$super;\n                var returnValue = null;\n\n                this.$super = parent[name];\n                returnValue = method.apply(this, arguments);\n\n                if (hasSuper) {\n                    this.$super = temp;\n                } else {\n                    delete this.$super;\n                }\n\n                return returnValue;\n\n            }\n            : method\n        );\n\n    }\n\n}\n\n/**\n * Creates a Class.\n *\n * @see    https://johnresig.com/blog/simple-javascript-inheritance/\n * @param  {Class} [Base]\n *         Optional parent class.\n * @param  {Object} proto\n *         Methods to add to the created Class' prototype.\n * @return {Class}\n *         Class created.\n */\nARIA.createClass = function (Base, proto) {\n\n    function Class() {\n        return this.init.apply(this, arguments);\n    }\n\n    if (!proto) {\n\n        proto = Base;\n        Base = Object;\n\n    }\n\n    Class.addMethod = addClassMethods;\n\n    /**\n     * Alias of {@link Class.addMethod}\n     */\n    Class.addMethods = addClassMethods;\n\n    /**\n     * Reference to the prototype of the Class' super-class.\n     * @type {Object}\n     */\n    Class.parent = Base.prototype;\n\n    Class.prototype = Object.create(Base.prototype);\n    addClassMethods.call(Class, proto);\n\n    Class.prototype.constructor = Class;\n\n    if (typeof Class.prototype.init !== \"function\") {\n        Class.prototype.init = noop;\n    }\n\n    return Class;\n\n};\n\n/**\n * A wrapper for setting an attribute on an element. This allows the method to\n * be easily replaced for virtual DOMs.\n *\n * @param {Element} element\n *        Element whose attribute should be set.\n * @param {String} name\n *        Name of the attribute to set.\n * @param {String} value\n *        Value of the attribute.\n */\nARIA.setAttribute = function (element, name, value) {\n    element.setAttribute(name, value);\n};\n\n/**\n * A wrapper for getting an attribute of an element. This allows the method to\n * be easily replaced for virtual DOMs.\n *\n * @param  {Element} element\n *         Element whose attribute should be retrieved.\n * @param  {String} name\n *         Name of the attribute to retrieve.\n * @return {String|null}\n *         The value of the attribute or null if that attribute does not exist.\n */\nARIA.getAttribute = function (element, name) {\n    return element.getAttribute(name);\n};\n\n/**\n * A wrapper for checking for an attribute on an element. This allows the method\n * to be easily replaced for virtual DOMs.\n *\n * @param  {Element} element\n *         Element whose attribute should be checked.\n * @param  {String} name\n *         Name of the attribute to check.\n * @return {Boolean}\n *         true if the element has the given attribute, false otherwise.\n */\nARIA.hasAttribute = function (element, name) {\n    return element.hasAttribute(name);\n};\n\n/**\n * A wrapper for removing an attribute from an element. This allows the method\n * to be easily replaced for virtual DOMs.\n *\n * @param {Element} element\n *        Element whose attribute should be removed.\n * @param {String} name\n *        Name of the attribute to remove.\n */\nARIA.removeAttribute = function (element, name) {\n    element.removeAttribute(name);\n};\n\n/**\n * Gets an element by the given ID. If the element cannot be found, null is\n * returned. This function is just a wrapper for document.getElementById to\n * allow the library to be easily modified in case a virtual DOM is being used.\n *\n * @param  {String} id\n *         ID of the element to find.\n * @return {Element|null}\n *         Element with the given ID or null if the element cannot be found.\n */\nARIA.getById = function (id) {\n    return document.getElementById(id);\n};\n\nvar counter = 0;\n\n/**\n * The default prefix for {@link ARIA.identify}.\n * @type {String}\n */\nARIA.defaultIdentifyPrefix = \"anonymous-element-\";\n\n/**\n * Returns the ID of the given element. If the element does not have an ID, a\n * unique one is generated. The generated ID is the given prefix and an\n * incrementing counter.\n * Pro tip: The HTML specs state that element IDs should start with a letter.\n *\n * @param  {Element} element\n *         Element whose ID should be returned.\n * @param  {String} [prefix=ARIA.defaultIdentifyPrefix]\n *         Prefix for the generated ID.\n * @return {String}\n *         The ID of the element.\n * @see    http://api.prototypejs.org/dom/Element/identify/\n */\nARIA.identify = function (element, prefix) {\n\n    var id = ARIA.getAttribute(element, \"id\");\n\n    if (prefix === undefined) {\n        prefix = ARIA.defaultIdentifyPrefix;\n    }\n\n    if (!id) {\n\n        do {\n\n            id = prefix + counter;\n            counter += 1;\n\n        } while (ARIA.getById(id));\n\n        ARIA.setAttribute(element, \"id\", id);\n\n    }\n\n    return id;\n\n};\n\n/**\n * Checks to see if the given value is a Node.\n *\n * @param  {?} value\n *         Value to test.\n * @return {Boolean}\n *         true if the given value is a Node, false otherwise.\n */\nARIA.isNode = function (value) {\n    return (value instanceof Node);\n};\n\n/**\n * A warning message for invalid tokens.\n * @type {String}\n */\nARIA.WARNING_INVALID_TOKEN = \"'{0}' is not a valid token for the '{1}' attribute\";\n\n/**\n * Replaces the placeholders in the string parameter with information from the\n * info parameter. Placeholders are wrapped in brackets e.g. \"{0}\".\n *\n * @param  {String} string\n *         String containing placeholders.\n * @param  {Array|Object} info\n *         Info to fill the string placeholders.\n * @return {String}\n *         Populated string.\n */\nARIA.supplant = function (string, info) {\n\n    return string.replace(/\\{(\\d+)\\}/g, function (whole, index) {\n\n        var arg = info[index];\n\n        return (\n            (typeof arg === \"string\" || typeof arg === \"number\")\n            ? arg\n            : whole\n        );\n\n    });\n\n};\n\n/**\n * A flag to enable warnings.\n * @type {Boolean}\n */\nARIA.enableWarnings = true;\n\n/**\n * Sends a warning.\n *\n * @param {String} message\n *        Message (and placeholders).\n * @param {Number|String} ...arguments\n *        Information to populate the message.\n */\nARIA.warn = function (message) {\n\n    if (ARIA.enableWarnings) {\n        console.warn(\"aria.js: \" + ARIA.supplant(message, slice(arguments, 1)));\n    }\n\n};\n\n/**\n * Handles basic WAI-ARIA properties.\n *\n * @class ARIA.Property\n */\nARIA.Property = ARIA.createClass(/** @lends ARIA.Property.prototype */{\n\n    /**\n     * @constructs ARIA.Property\n     * @param      {Element} element\n     *             Element whose attribute should be handled.\n     * @param      {String} attribute\n     *             Name of the attribute to handle.\n     * @param      {Array.<String>} [tokens]\n     *             Optional white-list of valid tokens for this property.\n     */\n    init: function (element, attribute, tokens) {\n\n        /**\n         * Element whose attribute is being handled.\n         * @type {Element}\n         */\n        this.element = element;\n\n        /**\n         * Attribute being handled.\n         * @type {String}\n         */\n        this.attribute = attribute;\n\n        /**\n         * White-list of valid tokens. This is a reference to a property of\n         * {@link ARIA.tokens} so updating that property will update all these\n         * instances.\n         * @type {Array.<String>}\n         */\n        this.tokens = (\n            (tokens && Array.isArray(tokens))\n            ? tokens\n            : []\n        );\n\n        // Things like ARIA.List work with interpretted values rather than just\n        // the attribute value. If the attribute already exists, pass the value\n        // to the set method to allow for that. As a bonus, this can filter out\n        // invalid attribute values.\n        if (ARIA.hasAttribute(element, attribute)) {\n            this.set(ARIA.getAttribute(element, attribute));\n        }\n\n    },\n\n    /**\n     * Interprets the given value so it can be set.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {String}\n     *         String based on the value.\n     */\n    interpret: function (value) {\n        return ARIA.Property.interpret(value);\n    },\n\n    /**\n     * Checks to see if the given token is valid for this current property. This\n     * function checks against {@link ARIA.Property#tokens}. If the token is not\n     * valid, a warning it sent. See {@link ARIA.warn}.\n     *\n     * @param  {String} token\n     *         Token to check.\n     * @return {Boolean}\n     *         true if the token is valid, false otherwise.\n     */\n    isValidToken: function (token) {\n\n        var isValid = (!this.tokens.length || this.tokens.indexOf(token) > -1);\n\n        if (!isValid) {\n            ARIA.warn(ARIA.WARNING_INVALID_TOKEN, token, this.attribute);\n        }\n\n        return isValid;\n\n    },\n\n    /**\n     * Gets the value of {@link ARIA.Property#attribute} and interprets it\n     * (see {@link ARIA.Property#interpret}). If {@link ARIA.Property#element}\n     * doesn't have {@link ARIA.Property#attribute} then null is returned.\n     *\n     * @return {String|null}\n     *         Interpretted value of {@link ARIA.Property#attribute} or null if\n     *         the attribute is not set.\n     */\n    get: function () {\n\n        var element = this.element;\n        var attribute = this.attribute;\n\n        return (\n            ARIA.hasAttribute(element, attribute)\n            ? this.interpret(ARIA.getAttribute(element, attribute))\n            : null\n        );\n\n    },\n\n    /**\n     * Sets {@link ARIA.Property#attribute} to the given value, once\n     * interpretted (see {@link ARIA.Property#interpret}) and validated (see\n     * {@link ARIA.Property#isValidToken}). If the value is interpretted as an\n     * empty string, the attribute is removed.\n     *\n     * @param {?} value\n     *        Value to set.\n     */\n    set: function (value) {\n\n        var element = this.element;\n        var attribute = this.attribute;\n        var interpretted = this.interpret(value);\n\n        if (interpretted !== \"\" && this.isValidToken(interpretted)) {\n            ARIA.setAttribute(element, attribute, interpretted);\n        } else if (interpretted === \"\") {\n            ARIA.removeAttribute(element, attribute);\n        }\n\n    },\n\n    /**\n     * Returns the value of {@link ARIA.Property#attribute} as a string. See\n     * {@link ARIA.Property#get}.\n     *\n     * @return {String}\n     *         Value of the attribute.\n     */\n    toString: function () {\n        return ARIA.getAttribute(this.element, this.attribute) || \"\";\n    }\n\n});\n\n/**\n * Interprets the given value so it can be set. This is used to power\n * {@link ARIA.Property#interpret} while also being exposed so other functions\n * and classes can use it.\n *\n * @param  {?} value\n *         Value to interpret.\n * @return {String}\n *         String based on the value.\n */\nARIA.Property.interpret = function (value) {\n\n    return (\n        (value === null || value === undefined)\n        ? \"\"\n        : String(value).trim()\n    );\n\n};\n\n/**\n * Handles number values.\n *\n * @class ARIA.Integer\n * @extends ARIA.Property\n */\nARIA.Number = ARIA.createClass(ARIA.Property, /** @lends ARIA.Number.prototype */{\n\n    /**\n     * Interprets the value as a number. If the value can't be converted into a\n     * number, NaN is returned.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Number}\n     *         Number value.\n     */\n    interpret: function (value) {\n        return parseFloat(this.$super(value));\n    },\n\n    /**\n     * @inheritDoc\n     */\n    isValidToken: function (value) {\n\n        var interpretted = this.interpret(value);\n        var isValid = !isNotANumber(interpretted);\n        var attribute = this.attribute;\n        var min = this.min;\n        var max = this.max;\n\n        if (!isValid) {\n            ARIA.warn(ARIA.WARNING_INVALID_TOKEN, value, attribute);\n        }\n\n        return isValid;\n\n    }\n\n});\n\n/**\n * Handles number values.\n *\n * @class ARIA.Integer\n * @extends ARIA.Number\n */\nARIA.Integer = ARIA.createClass(ARIA.Number, /** @lends ARIA.Integer.prototype */{\n\n    /**\n     * Interprets the value as an integer. If the value can't be converted into\n     * a number, NaN is returned.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Number}\n     *         Number value.\n     */\n    interpret: function (value) {\n        return Math.floor(this.$super(value));\n    }\n\n});\n\n/**\n * Handles WAI-ARIA states.\n *\n * @class ARIA.State\n * @extends ARIA.Property\n */\nARIA.State = ARIA.createClass(ARIA.Property, /** @lends ARIA.State.prototype */{\n\n    /**\n     * Unlike the parent {@link ARIA.Property}, an instance of ARIA.State cannot\n     * have tokens set.\n     *\n     * @constructs ARIA.State\n     * @param      {Element} element\n     *             Element whose attribute should be handled.\n     * @param      {String} attribute\n     *             Name of the attribute to handle.\n     */\n    init: function (element, attribute) {\n\n        this.$super(element, attribute, [\n            \"true\",\n            \"false\"\n        ]);\n\n    },\n\n    /**\n     * @inheritDoc\n     */\n    isValidToken: function (token) {\n        return typeof token === \"boolean\" || this.$super(token);\n    },\n\n    /**\n     * Coerces the given value into a boolean.\n     *\n     * @param  {?} value\n     *         Value to coerce.\n     * @return {Boolean|String}\n     *         Coerced boolean or an empty string.\n     */\n    interpret: function (value) {\n\n        var interpretted = this.$super(value);\n        var isTrue = interpretted === \"true\";\n\n        return (\n            (isTrue || interpretted === \"false\")\n            ? isTrue\n            : interpretted\n        );\n\n    }\n\n});\n\n/**\n * Handles a WAI-ARIA state that can be true or false but can also be undefined.\n *\n * @class ARIA.UndefinedState\n * @extends ARIA.State\n */\nARIA.UndefinedState = ARIA.createClass(ARIA.State, /** @lends ARIA.UndefinedState.prototype */{\n\n    /**\n     * @inheritDoc\n     */\n    init: function (element, attribute) {\n\n        this.$super(element, attribute);\n        this.tokens.push(\"undefined\");\n\n    },\n\n    /**\n     * @inheritDoc\n     */\n    isValidToken: function (token) {\n        return token === undefined || this.$super(token);\n    },\n\n    /**\n     * Interprets undefined as \"undefined.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Boolean|String}\n     *         Either the boolean value, \"undefined\" or an empty string if the\n     *         value is not understood.\n     */\n    interpret: function (value) {\n\n        return (\n            (value === undefined || value === \"undefined\")\n            ? \"undefined\"\n            : this.$super(value)\n        );\n\n    },\n\n    /**\n     * Returns a boolean or undefined.\n     *\n     * @return {Boolean|undefined}\n     *         Value of the attribute.\n     */\n    get: function () {\n\n        var value = this.$super();\n\n        if (value === \"undefined\") {\n            value = undefined;\n        }\n\n        return value;\n\n    }\n\n});\n\n/**\n * Handles WAI-ARIA tristates. That is, a state that can be either true, false\n * or \"mixed\".\n *\n * @class ARIA.Tristate\n * @extends ARIA.State\n */\nARIA.Tristate = ARIA.createClass(ARIA.State, /** @lends ARIA.Tristate.prototype */{\n\n    /**\n     * @inheritDoc\n     */\n    init: function (element, attribute) {\n\n        this.$super(element, attribute);\n        this.tokens.push(\"mixed\");\n\n    },\n\n    /**\n     * Allows the token \"mixed\".\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Boolean|String}\n     *         Either the boolean value, \"mixed\" or an empty string if the value\n     *         is not understood.\n     */\n    interpret: function (value) {\n\n        return (\n            value === \"mixed\"\n            ? value\n            : this.$super(value)\n        );\n\n    }\n\n});\n\n/**\n * Handles a WAI-ARIA attribute that should be a space-separated list.\n *\n * @class ARIA.List\n * @extends ARIA.Property\n */\nARIA.List = ARIA.createClass(ARIA.Property, /** ARIA.List.prototype */{\n\n    /**\n     * @inheritDoc\n     */\n    init: function (element, attribute, tokens) {\n\n        /**\n         * The list of values.\n         * @type {Array.<String>}\n         */\n        this.list = [];\n\n        this.$super(element, attribute, tokens);\n\n    },\n\n    /**\n     * Coerces the values into a string and splits it at the spaces.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {Array.<String>}\n     *         Array of strings.\n     */\n    interpret: function (value) {\n\n        var val = (\n            Array.isArray(value)\n            ? value.join(\" \")\n            : value\n        );\n        var string = this.$super(val);\n\n        return (\n            string.length\n            ? string.split(/\\s+/)\n            : []\n        );\n\n    },\n\n    /**\n     * Sets the value of the list to be the given value. The values are\n     * interpretted as an array (see {@link ARIA.List#interpret} and validated\n     * (see {@link ARIA.List#isValidToken}); only unique values are added.\n     *\n     * @param {?} value\n     *        Value(s) to add. If the given value is a string, it is assumed to\n     *        be a space-separated list.\n     */\n    set: function (value) {\n\n        var that = this;\n        var values = that.interpret(value).reduce(function (unique, token) {\n\n            if (\n                token\n                && that.isValidToken(token)\n                && unique.indexOf(token) < 0\n            ) {\n                unique.push(token);\n            }\n\n            return unique;\n\n        }, []);\n        var element = that.element;\n        var attribute = that.attribute;\n\n        that.list = values;\n\n        if (values.length) {\n            ARIA.setAttribute(element, attribute, values.join(\" \"));\n        } else {\n            ARIA.removeAttribute(element, attribute);\n        }\n\n    },\n\n    /**\n     * Gets the value of the attribute as an array.\n     *\n     * @return {Array.<String>}\n     *         Value of the attribute as an array.\n     */\n    get: function () {\n        return this.list.concat();\n    }\n\n});\n\n/**\n * Handles WAI-ARIA attributes that reference a single ID.\n *\n * @class ARIA.Reference\n * @extends ARIA.Property\n */\nARIA.Reference = ARIA.createClass(ARIA.Property, /** @lends ARIA.Reference.prototype */{\n\n    /**\n     * Interprets the given value as a string. If the value is an element, the\n     * element's ID is returned, generating one if necessary - see\n     * {@link ARIA.identify}.\n     *\n     * @param  {?} value\n     *         Value to interpret.\n     * @return {String}\n     *         The interpretted value.\n     */\n    interpret: function (value) {\n        return ARIA.Reference.interpret(value);\n    },\n\n    /**\n     * Gets the element referenced by this attribute. If the element cannot be\n     * found or the attribute isn't set, null is returned.\n     *\n     * @return {Element|null}\n     *         Element referenced by this attribute or null if the element\n     *         cannot be found or the attribute isn't set.\n     */\n    get: function () {\n        return ARIA.getById(this.$super());\n    }\n\n});\n\n/**\n * Interprets the given value as a string. If the value is an element, the\n * element's ID is returned, generating one if necessary = see\n * {@link ARIA.identify}. This powers {@link ARIA.Reference#interpret} while\n * also allowing other functions and classes to use it.\n *\n * @param  {?} value\n *         Value to interpret.\n * @return {String}\n *         The interpretted value.\n */\nARIA.Reference.interpret = function (value) {\n\n    return (\n        ARIA.isNode(value)\n        ? ARIA.identify(value)\n        : ARIA.Property.interpret(value)\n    );\n\n};\n\n/**\n * Handles WAI-ARIA attributes that handle space-separated lists of IDs.\n * @class ARIA.ReferenceList\n * @extends ARIA.List\n */\nARIA.ReferenceList = ARIA.createClass(ARIA.List, /** @lends ARIA.ReferenceList.prototype */{\n\n    /**\n     * Interprets an element, ID or array of elements or/and IDs as an array of\n     * element IDs.\n     *\n     * @param  {Array.<Element|String>|Element|String} value\n     *         Value(s) to interpret.\n     * @return {Array.<String>}\n     *         Collection of IDs.\n     */\n    interpret: function (value) {\n\n        var interpretted = [];\n\n        if (\n            value\n            && typeof value === \"object\"\n            && typeof value.length === \"number\"\n        ) {\n            interpretted = arrayFrom(value, ARIA.Reference.interpret, this);\n        } else if (typeof value === \"string\") {\n            interpretted = this.$super(value);\n        } else {\n            interpretted = [ARIA.Reference.interpret(value)];\n        }\n\n        // Remove all falsy values such as \"\" or null.\n        return interpretted.filter(Boolean);\n\n    },\n\n    /**\n     * Gets an array of elements referenced by the attribute. If the element\n     * cannot be found, null will be in place of the element.\n     *\n     * @return {Array.<Element|null>}\n     *         Array of elements.\n     */\n    get: function () {\n        return this.$super().map(ARIA.getById);\n    }\n\n});\n\n/**\n * Handles the WAI-ARIA attributes on an element.\n *\n * @class ARIA.Element\n */\nARIA.Element = ARIA.createClass(/** @lends ARIA.ELement.prototype */{\n\n    /**\n     * @constructs ARIA.Element\n     * @param      {Element} element\n     *             Element whose WAI-ARIA attributes should be handled.\n     */\n    init: function (element) {\n\n        /**\n         * Element whose WAI-ARIA attributes should be handled.\n         * @type {Element}\n         */\n        this.element = element;\n\n        /**\n         * A flag object that keeps track of attributes being modified. Prevents\n         * infinitely loops being caused in the MutationObserver.\n         * @type {Object}\n         */\n        // this.manipulationFlags = Object.create(null);\n\n        /**\n         * Instances of {@link ARIA.Property} (or sub-classes) that are used to\n         * check get and set values.\n         * @type {Object}\n         */\n        this.instances = Object.create(null);\n\n        // this.preloadAttributes();\n        this.readAttributes();\n        this.observeAttributes();\n\n        return this.activateTraps();\n\n    },\n\n    /**\n     * Gets the instance from {@link ARIA.Element#instances} for the given\n     * attribute. If the instance does not exist but a factory exists, the\n     * instance is created and stored before being returned.\n     *\n     * @param  {String} attribute\n     *         Attribute whose instance should be found.\n     * @return {ARIA.Property}\n     *         Instance of {@link ARIA.Property} (or sub-class).\n     */\n    getInstance: function (attribute) {\n\n        var instance = this.instances[attribute];\n\n        if (!instance && ARIA.getFactory(attribute)) {\n\n            instance = ARIA.runFactory(attribute, this.element);\n            this.instances[attribute] = instance;\n\n        }\n\n        return instance;\n\n    },\n\n    /**\n     * Reads all the WAI-ARIA attributes on {@link ARIA.Element#element} and\n     * sets the {@link ARIA.Property} values.\n     */\n    readAttributes: function () {\n\n        arrayFrom(this.element.attributes, function (attribute) {\n\n            var value = attribute.value;\n            var instance = (\n                value\n                ? this.getInstance(attribute.name)\n                : undefined\n            );\n\n            if (instance) {\n                instance.set(value);\n            }\n\n        }, this);\n\n    },\n\n    /**\n     * Creates the observer {@link ARIA.Element#observer} that listens for\n     * changes to WAI-ARIA attribtues and updates the {@link ARIA.Property}\n     * values.\n     */\n    observeAttributes: function () {\n\n        var that = this;\n\n        /**\n         * The observer.\n         * @type {MutationObserver}\n         */\n        that.observer = ARIA.Element.makeObserver(\n            that.element,\n            function (data) {\n                return Boolean(ARIA.factories[data.suffix]);\n            },\n            function (data) {\n                that[data.suffix] = data.value;\n            },\n            function (data) {\n                that[data.suffix] = \"\";\n            }\n        );\n\n    },\n\n    /**\n     * Disconnects {@link ARIA.Element#observer}.\n     */\n    disconnectAttributes: function () {\n        this.observer.disconnect();\n    },\n\n    /**\n     * Activates the get, set and delete traps for the instance which enables\n     * the interface.\n     *\n     * @return {Proxy}\n     *         Proxy of the instance (if the browser supports it).\n     */\n    activateTraps: function () {\n\n        return new Proxy(this, {\n\n            get: function (target, name) {\n\n                var value = target[name];\n                var instance = target.getInstance(name);\n\n                if (instance) {\n                    value = instance.get();\n                }\n\n                return value;\n\n            },\n\n            set: function (target, name, value) {\n\n                var instance = target.getInstance(name);\n\n                if (instance) {\n                    instance.set(value);\n                } else {\n                    target[name] = value;\n                }\n\n                return true;\n\n            },\n\n            deleteProperty: function (target, name) {\n\n                var instance = target.getInstance(name);\n\n                if (instance) {\n                    instance.set(\"\");\n                } else {\n                    delete target[name];\n                }\n\n                return true;\n\n            }\n\n        });\n\n    }\n\n});\n\n/**\n * Creates an observer to listen for attribute changes.\n *\n * @param  {Element} element\n *         Element whose attribute changes should be observed.\n * @param  {Function} checker\n *         Function to execute when checking whether the attribute change should\n *         be observed. Accepts an object with \"attribute\" and \"suffix\"\n *         properties, returns a boolean.\n * @param  {Function} setter\n *         Function to execute when an attribute change has been detected.\n *         Accepts an object and \"attribute\", \"suffix\", \"value\" and \"old\"\n *         properties.\n * @param  {Function} unsetter\n *         Function to execute when an attribute has been removed. Accepts an\n *         object with \"attribute\" and \"suffix\" properties.\n * @return {MutationObserver}\n *         MutationObserver that observes the attribute changes.\n */\nARIA.Element.makeObserver = function (element, checker, setter, unsetter) {\n\n    var manipulationFlags = Object.create(null);\n    var observer = new MutationObserver(function (mutations) {\n\n        mutations.forEach(function (mutation) {\n\n            var attribute = mutation.attributeName || \"\";\n            var suffix = ARIA.getSuffix(attribute);\n            var data = {\n                attribute: attribute,\n                suffix: suffix\n            };\n\n            if (\n                mutation.type === \"attributes\"\n                && !manipulationFlags[suffix]\n                && checker(data)\n            ) {\n\n                manipulationFlags[suffix] = true;\n\n                if (ARIA.hasAttribute(element, attribute)) {\n\n                    data.value = ARIA.Property.interpret(\n                        ARIA.getAttribute(element, attribute)\n                    );\n                    data.old = ARIA.Property.interpret(mutation.oldValue);\n                    setter(data);\n\n                } else {\n                    unsetter(data);\n                }\n\n                requestAnimationFrame(function () {\n                    delete manipulationFlags[suffix];\n                });\n\n            }\n\n        });\n\n    });\n\n    observer.observe(element, {\n        attributes: true,\n        attributeOldValue: true\n    });\n\n    return observer;\n\n};\n\n// Create a fall-back for browsers that don't understand Proxy.\n// Object.defineProperty can be used for get and set, but delete will have to\n// rely on polling.\nif (!globalVariable.Proxy) {\n\n    ARIA.Element.prototype.activateTraps = function () {\n\n        var that = this;\n        var owns = Object.prototype.hasOwnProperty.bind(that);\n\n        Object.keys(ARIA.factories).forEach(function setProperty(attribute) {\n\n            var isPolling = false;\n\n            Object.defineProperty(that, attribute, {\n\n                configurable: true,\n\n                get: function () {\n                    return that.getInstance(attribute).get();\n                },\n\n                set: function (value) {\n\n                    var instance = that.getInstance(attribute);\n\n                    if (value === \"\") {\n                        isPolling = false;\n                    } else if (value !== \"\" && !isPolling) {\n\n                        requestAnimationFrame(function poll() {\n\n                            if (isPolling) {\n\n                                if (owns(attribute)) {\n\n                                    requestAnimationFrame(poll);\n                                    isPolling = true;\n\n                                } else {\n\n                                    isPolling = false;\n                                    instance.set(\"\");\n                                    setProperty(attribute);\n\n                                }\n\n                            }\n\n                        });\n                        isPolling = true;\n\n                    }\n\n                    return instance.set(value);\n\n                }\n\n            });\n\n        });\n\n    };\n\n}\n\n/**\n * Collection of factories for creating WAI-ARIA libraries. The attribute key\n * should be the attribute suffixes (e.g. \"label\" for \"aria-label\" etc.)\n * @type {Object}\n */\nARIA.factories = Object.create(null);\n\n/**\n * Gets the factory from {@link ARIA.factories} that matches either the given\n * attribute or the normalised version (see {@link ARIA.normalise}).\n *\n * @param  {String} attribute\n *         Attribute whose factory should be returned.\n * @return {Function}\n *         Factory for creating the attribute.\n */\nARIA.getFactory = function (attribute) {\n\n    return (\n        ARIA.factories[attribute]\n        || ARIA.factories[ARIA.getSuffix(ARIA.normalise(attribute))]\n    );\n\n};\n\n/**\n * Executes the factory for the given attribute, passing in given parameters.\n * See {@link ARIA.getFactory}.\n *\n * @param  {String} attribute\n *         Attribute whose factory should be executed.\n * @param  {Element} element\n *         Element that should be passed to the factory.\n * @return {ARIA.Property}\n *         Instance of {@link ARIA.Property} (or sub-class) created by the\n *         factory.\n * @throws {ReferenceError}\n *         There must be a factory for the given attribute.\n */\nARIA.runFactory = function (attribute, element) {\n\n    var factory = ARIA.getFactory(attribute);\n\n    if (!factory) {\n        throw new ReferenceError(attribute + \" is not a recognised factory\");\n    }\n\n    return factory(element);\n\n};\n\n/**\n * Creates a factory that creates an aria property.\n *\n * @param  {String} attribute\n *         Normalised name of the attribute whose factory is created.\n * @param  {Function} Constructor\n *         Constructor for {@link ARIA.Property} (or sub-class) that will create\n *         the property.\n * @param  {Function} [modify]\n *         Optional function for modifying the {@link ARIA.Property} instance\n *         before it's returned.\n * @return {Function}\n *         A factory function that takes the element and returns the instance.\n */\nARIA.makeFactory = function (attribute, Constructor/*, modify*/) {\n\n    return function (element) {\n\n        var instance;\n        var tokens = ARIA.tokens[attribute];\n\n        if (!tokens) {\n\n            tokens = [];\n            ARIA.tokens[attribute] = tokens;\n\n        }\n\n        instance = new Constructor(element, attribute, tokens);\n\n        // if (typeof modify === \"function\") {\n        //     modify(instance);\n        // }\n\n        return instance;\n\n    };\n\n};\n\nvar factoryEntries = [\n    [ARIA.Property, [\n        \"autocomplete\",\n        \"current\",\n        \"haspopup\",\n        \"invalid\",\n        \"keyshortcuts\",\n        \"label\",\n        \"live\",\n        \"orientation\",\n        \"placeholder\",\n        \"roledescription\",\n        \"sort\",\n        \"valuetext\"\n    ]],\n    [ARIA.Reference, [\n        \"activedescendant\",\n        \"details\",\n        \"errormessage\"\n    ]],\n    [ARIA.ReferenceList, [\n        \"controls\",\n        \"describedby\",\n        \"flowto\",\n        \"labelledby\",\n        \"owns\"\n    ]],\n    [ARIA.State, [\n        \"atomic\",\n        \"busy\",\n        \"disabled\",\n        \"modal\",\n        \"multiline\",\n        \"multiselectable\",\n        \"readonly\",\n        \"required\"\n    ]],\n    [ARIA.Tristate, [\n        \"checked\",\n        \"pressed\"\n    ]],\n    [ARIA.UndefinedState, [\n        \"expanded\",\n        \"grabbed\",\n        \"hidden\",\n        \"selected\"\n    ]],\n    [ARIA.Integer, [\n        \"colcount\",\n        \"colindex\",\n        \"colspan\",\n        \"level\",\n        \"posinset\",\n        \"rowcount\",\n        \"rowindex\",\n        \"rowspan\",\n        \"setsize\"\n    ]],\n    [ARIA.Number, [\n        \"valuemax\",\n        \"valuemin\",\n        \"valuenow\"\n    ]],\n    [ARIA.List, [\n        \"dropeffect\",\n        \"relevant\",\n        \"role\"\n    ]]\n];\n\nfactoryEntries.forEach(function (entry) {\n\n    entry[1].forEach(function (attribute) {\n\n        ARIA.factories[attribute] = ARIA.makeFactory(\n            ARIA.normalise(attribute),\n            entry[0]\n        );\n\n    });\n\n});\n\n/**\n * Creates an alias of WAI-ARIA attributes.\n *\n * @param  {String} source\n *         Source attribute for the alias.\n * @param  {Array.<String>|String} aliases\n *         Either a single alias or an array of aliases.\n * @throws {ReferenceError}\n *         The source attribute must have a related factory.\n */\nARIA.addAlias = function (source, aliases) {\n\n    var normalSource = ARIA.normalise(source).slice(5);\n\n    if (!Array.isArray(aliases)) {\n        aliases = [aliases];\n    }\n\n    if (!ARIA.getFactory(normalSource)) {\n\n        throw new ReferenceError(\n            \"ARIA.factories.\"\n            + normalSource\n            + \" does not exist\"\n        );\n\n    }\n\n    aliases.forEach(function (alias) {\n\n        var normalAlias = ARIA.normalise(alias).slice(5);\n\n        ARIA.translate[normalAlias] = normalSource;\n        ARIA.factories[normalAlias] = ARIA.factories[normalSource];\n\n    });\n\n};\n\nARIA.addAlias(\"labelledby\", \"labeledby\");\n\n/**\n * @file    Adds the \"aria\" and \"role\" properties to Node.prototype if ARIA is\n *          set up to allow it.\n * @author  James \"Skateside\" Long\n * @license MIT\n */\n(function (ARIA) {\n\n    \"use strict\";\n\n    var nodeProto = Node.prototype;\n    var ariaProp;\n    var roleProp;\n\n    function getString(source, property) {\n\n        return (\n            typeof source[property] === \"string\"\n            ? source[property].trim()\n            : \"\"\n        );\n\n    }\n\n    if (ARIA && ARIA.extendDOM) {\n\n        ariaProp = getString(ARIA.extendDOM, \"aria\");\n        roleProp = getString(ARIA.extendDOM, \"role\");\n\n        if (ariaProp && roleProp && ariaProp === roleProp) {\n\n            throw new Error(\n                \"ARIA.extendDOM.aria and ARIA.extendDOM.role cannot be the same\"\n            );\n\n        }\n\n        if (ariaProp) {\n\n            // https://github.com/LeaVerou/bliss/issues/49\n            Object.defineProperty(nodeProto, ariaProp, {\n\n                configurable: true,\n\n                get: function getter() {\n\n                    var object = this;\n\n                    Object.defineProperty(nodeProto, ariaProp, {\n                        get: undefined\n                    });\n\n                    Object.defineProperty(object, ariaProp, {\n                        value: new ARIA.Element(object)\n                    });\n\n                    Object.defineProperty(nodeProto, ariaProp, {\n                        get: getter\n                    });\n\n                    return object[ariaProp];\n\n                }\n\n            });\n\n            if (roleProp) {\n\n                Object.defineProperty(nodeProto, roleProp, {\n\n                    configurable: true,\n\n                    get: function () {\n                        return this[ariaProp].role;\n                    },\n\n                    set: function (value) {\n                        this[ariaProp].role = value;\n                    }\n\n                });\n\n            }\n\n        }\n\n    }\n\n}(window.ARIA));\n}(window));"],"file":"aria.min.js"}