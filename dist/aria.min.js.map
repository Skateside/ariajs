{"version":3,"sources":["aria.js"],"names":["globalVariable","identity","x","arrayFrom","Array","from","arrayLike","map","context","undefined","prototype","call","objectAssign","Object","assign","source","forEach","arguments","object","i","keys","key","noop","fnTest","test","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setTimeout","interpretString","value","String","trim","slice","start","stringifyArguments","JSON","stringify","owns","property","hasOwnProperty","ARIA","defineProperty","configurable","enumerable","writable","previousAria","addClassMethods","name","method","parent","this","returnValue","hasSuper","temp","$super","apply","getPrevious","restorePrevious","memoise","func","keyMaker","cache","create","args","response","prefixCache","suffixCache","translate","labeledby","role","PREFIX_REGEXP","addPrefix","attribute","removed","removePrefix","toLowerCase","replace","createClass","Base","proto","Class","init","addMethod","addMethods","constructor","setAttribute","element","getAttribute","hasAttribute","removeAttribute","getById","id","document","getElementById","counter","defaultIdentifyPrefix","identify","prefix","isNode","Node","observerMap","WeakMap","Observer","getEventElement","dummy","get","createElement","set","createEvent","detail","CustomEvent","bubbles","cancelable","dispatchEvent","event","addEventListener","handler","removeEventListener","ignore","initCustomEvent","observer","trigger","on","off","Property","interpret","preEvent","EVENT_PRE_GET","defaultPrevented","EVENT_POST_GET","interpretted","eventData","raw","EVENT_PRE_SET","remove","EVENT_POST_SET","EVENT_PRE_REMOVE","EVENT_POST_REMOVE","toString","Number","parseFloat","Integer","Math","floor","State","isTrue","UndefinedState","Tristate","List","list","val","isArray","join","string","length","split","values","reduce","unique","item","indexOf","push","Reference","ReferenceList","filter","Boolean","Element","instances","readAttributes","observeAttributes","activateTraps","getInstance","instance","getFactory","runFactory","attributes","that","makeObserver","data","factories","suffix","disconnectAttributes","disconnect","Proxy","target","deleteProperty","checker","setter","unsetter","manipulationFlags","MutationObserver","mutations","mutation","attributeName","type","old","oldValue","observe","attributeOldValue","setProperty","isPolling","poll","factory","ReferenceError","makeFactory","Constructor","factoryEntries","createFactories","entry","addAlias","aliases","alias","normalAlias","window"],"mappings":"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","sourcesContent":["/*! ariajs - v0.2.0 - MIT license - https://github.com/Skateside/ariajs - 2018-12-30 */\n(function (globalVariable) {\n    \"use strict\";\n\n/**\r\n * A function that returns the given variable unchanged.\r\n *\r\n * @private\r\n * @param   {?} x\r\n *          Variable to return.\r\n * @return  {?}\r\n *          Unmodified original variable.\r\n */\r\nvar identity = function (x) {\r\n    return x;\r\n};\r\n\r\n/**\r\n * A simple fall-back for Array.from.\r\n *\r\n * @private\r\n * @param   {Object} arrayLike\r\n *          Array-like structure.\r\n * @param   {Function} [map=identity]\r\n *          Optional function to convert the values.\r\n * @param   {?} [context]\r\n *          Optional context for the map function.\r\n * @return  {Array}\r\n *          Array made from the iven array-like structure.\r\n */\r\nvar arrayFrom = Array.from || function (arrayLike, map, context) {\r\n\r\n    if (map === undefined) {\r\n        map = identity;\r\n    }\r\n\r\n    return Array.prototype.map.call(arrayLike, map, context);\r\n\r\n};\r\n\r\n/**\r\n * A simple fall-back for Object.assign.\r\n *\r\n * @private\r\n * @param   {Object} source\r\n *          Source object to modify.\r\n * @param   {Object} [...objects]\r\n *          Additional objects to extend the first.\r\n * @return  {Object}\r\n *          Extended object.\r\n */\r\nvar objectAssign = Object.assign || function (source) {\r\n\r\n    Array.prototype.forEach.call(arguments, function (object, i) {\r\n\r\n        // Skip null objects and the first one (source parameter).\r\n        if (object && i > 0) {\r\n\r\n            Object.keys(object).forEach(function (key) {\r\n                source[key] = object[key];\r\n            });\r\n\r\n        }\r\n\r\n    });\r\n\r\n    return source;\r\n\r\n};\r\n\r\n/**\r\n * A function that does nothing.\r\n *\r\n * @private\r\n */\r\nvar noop = function () {\r\n    return;\r\n};\r\n\r\n/**\r\n * The regular expression used to test functions for whether or not they include\r\n * the \"$super\" magic property.\r\n * @private\r\n * @type    {RegExp}\r\n */\r\nvar fnTest = (\r\n    (/return/).test(noop)\r\n    ? (/[.'\"]\\$super\\b/)\r\n    : (/.*/)\r\n);\r\n\r\n/**\r\n * A reference (and possible fallback) for requestAnimationFrame.\r\n *\r\n * @private\r\n * @function\r\n * @param    {Function} callback\r\n *           Function to execute when the animation frame ticks over.\r\n */\r\nvar requestAnimationFrame = (\r\n    globalVariable.requestAnimationFrame\r\n    || globalVariable.webkitRequestAnimationFrame\r\n    || globalVariable.mozRequestAnimationFrame\r\n    || function (callback) {\r\n        globalVariable.setTimeout(callback, 1000 / 60);\r\n    }\r\n);\r\n\r\n/**\r\n * Interprets a value so that it is a string. If the given value is null or\r\n * undefined, an empty string is returned.\r\n *\r\n * @private\r\n * @param   {?} value\r\n *          Value to convert into a string.\r\n * @return  {String}\r\n *          Interpretted string.\r\n */\r\nvar interpretString = function (value) {\r\n\r\n    return (\r\n        (value === \"\" || value === null || value === undefined)\r\n        ? \"\"\r\n        : String(value).trim()\r\n    );\r\n\r\n};\r\n\r\n/**\r\n * Create a lower-case version of {@link interpretString}.\r\n *\r\n * @private\r\n * @param   {?} value\r\n *          Value to convert into a string.\r\n * @return  {String}\r\n *          Interpretted lower-case string.\r\n */\r\nvar interpretLowerString = function (value) {\r\n    return interpretString(value).toLowerCase();\r\n};\r\n\r\n/**\r\n * Helper function for slicing array-like objects.\r\n *\r\n * @private\r\n * @param   {Object} arrayLike\r\n *          Array-like structure.\r\n * @param   {Number} [start]\r\n *          Optional start for the slice.\r\n * @return  {Array}\r\n *          Sliced array.\r\n */\r\nvar slice = function (arrayLike, start) {\r\n    return Array.prototype.slice.call(arrayLike, start);\r\n};\r\n\r\n/**\r\n * Takes the arguments and converts them into a valid JSON string.\r\n *\r\n * @private\r\n * @return  {String}\r\n *          JSON string based on the given arguments.\r\n */\r\nvar stringifyArguments = function () {\r\n    return JSON.stringify(slice(arguments));\r\n};\r\n\r\n/**\r\n * Checks to see if the given object has the given property.\r\n *\r\n * @private\r\n * @param   {Object} object\r\n *          Object whose property's existence should be checked.\r\n * @param   {String} property\r\n *          Name of the property to check for.\r\n * @return  {Boolean}\r\n *          true if the object has the property, false otherwise.\r\n */\r\nvar owns = function (object, property) {\r\n    return Object.prototype.hasOwnProperty.call(object, property);\r\n};\r\n\r\n/**\r\n * Removes duplicated values from the given array.\r\n *\r\n * @param  {Array} array\r\n *         Array to reduce.\r\n * @return {Array}\r\n *         Array containing unique values.\r\n */\r\nvar arrayUnique = function (array) {\r\n\r\n    return array.reduce(function (unique, item) {\r\n\r\n        if (unique.indexOf(item) < 0) {\r\n            unique.push(item);\r\n        }\r\n\r\n        return unique;\r\n\r\n    }, []);\r\n\r\n};\r\n\r\n/**\r\n * @namespace\r\n */\r\nvar ARIA = {};\r\n\r\n/**\r\n * The version of the library.\r\n *\r\n * @memberof ARIA\r\n * @type {String}\r\n * @constant\r\n * @name VERSION\r\n */\r\nObject.defineProperty(ARIA, \"VERSION\", {\r\n    configurable: false,\r\n    enumerable: true,\r\n    writable: false,\r\n    value: \"0.2.0\"\r\n});\r\n\r\nvar previousAria = globalVariable.ARIA;\r\nglobalVariable.ARIA = ARIA;\r\n\r\n/**\r\n * Returns the previous value of the global ARIA variable.\r\n *\r\n * @return {?}\r\n *         Previous ARIA value.\r\n */\r\nARIA.getPrevious = function () {\r\n    return previousAria;\r\n};\r\n\r\n/**\r\n * Removes the value of {@link ARIA} from the global variable and sets it back\r\n * to the previous value. This version of {@link ARIA} is returned.\r\n *\r\n * @return {Object}\r\n *         Current version of {@link ARIA}.\r\n */\r\nARIA.restorePrevious = function () {\r\n\r\n    globalVariable.ARIA = previousAria;\r\n\r\n    return ARIA;\r\n\r\n};\r\n\r\n/**\r\n * Memoises a function so that the cached values are returned if they exist.\r\n *\r\n * @param  {Function} func\r\n *         Function to cache,\r\n * @param  {Function} [keyMaker]\r\n *         Optional function to create the cache's key.\r\n * @param  {Object} [cache]\r\n *         Optional cache for the function.\r\n * @return {Function}\r\n *         Memoised function.\r\n */\r\nARIA.memoise = function (func, keyMaker, cache) {\r\n\r\n    var context = this;\r\n\r\n    if (cache === undefined) {\r\n        cache = Object.create(null);\r\n    }\r\n\r\n    if (keyMaker === undefined) {\r\n        keyMaker = stringifyArguments;\r\n    }\r\n\r\n    return function () {\r\n\r\n        var args = slice(arguments);\r\n        var key = keyMaker.apply(context, args);\r\n        var response = cache[key];\r\n\r\n        if (!owns(cache, key)) {\r\n\r\n            response = func.apply(context, args);\r\n            cache[key] = response;\r\n\r\n        }\r\n\r\n        return response;\r\n\r\n    };\r\n\r\n};\r\n\r\n/**\r\n * The cache for {@link ARIA.addPrefix}. See also {@link ARIA.translate}.\r\n * @type {Object}\r\n */\r\nARIA.prefixCache = Object.create(null);\r\n\r\n/**\r\n * The cache for {@link ARIA.removePrefix}.\r\n * @type {Object}\r\n */\r\nARIA.suffixCache = Object.create(null);\r\n\r\n/**\r\n * Translations for after the {@link ARIA.addPrefix} process has happened.\r\n * Unlike {@link ARIA.prefixCache}, this map translates values that have already\r\n * been processed (trimmed and converted into lower-case). As such, it's\r\n * probably easier to modify this map than the cache.\r\n * @type {Object}\r\n */\r\nARIA.translate = objectAssign(Object.create(null), {\r\n    \"labeledby\": \"aria-labelledby\",\r\n    \"role\": \"role\"\r\n});\r\n\r\n/**\r\n * The regular expression used to match the WAI-ARIA prefix.\r\n * @type {RegExp}\r\n */\r\nARIA.PREFIX_REGEXP = (/^(aria\\-)?/);\r\n\r\n/**\r\n * Adds the WAI-ARIA prefix to the given attribute if it doesn't already have\r\n * it.\r\n *\r\n * @function\r\n * @param    {String} attribute\r\n *           Attribute that should be prefixed with \"aria-\", if it isn't\r\n *           already.\r\n */\r\nARIA.addPrefix = ARIA.memoise(\r\n    function (attribute) {\r\n\r\n        var removed = ARIA.removePrefix(attribute);\r\n\r\n        return ARIA.translate[removed] || (\"aria-\" + removed);\r\n\r\n    },\r\n    identity,\r\n    ARIA.prefixCache\r\n);\r\n\r\n/**\r\n * Removes the WAI-ARIA prefix from the given attribute if it has it.\r\n *\r\n * @function\r\n * @param    {String} attribute\r\n *           Attribute that should have the \"aria-\" prefix removed.\r\n */\r\nARIA.removePrefix = ARIA.memoise(\r\n    function (attribute) {\r\n        return interpretLowerString(attribute).replace(ARIA.PREFIX_REGEXP, \"\");\r\n    },\r\n    identity,\r\n    ARIA.suffixCache\r\n);\r\n\r\n/**\r\n * Adds one or more methods to the class.\r\n *\r\n * @memberof Class\r\n * @name     addMethod\r\n * @static\r\n * @param    {Object|String} name\r\n *           Either the name of the method to add or an object of names to\r\n *           methods.\r\n * @param    {Function} [method]\r\n *           Method to add to the class.\r\n */\r\nfunction addClassMethods(name, method) {\r\n\r\n    var parent = this.parent;\r\n\r\n    if (typeof name === \"object\") {\r\n\r\n        Object.keys(name).forEach(function (key) {\r\n            addClassMethods.call(this, key, name[key]);\r\n        }, this);\r\n\r\n    } else {\r\n\r\n        this.prototype[name] = (\r\n            (\r\n                typeof method === \"function\"\r\n                && typeof parent[name] === \"function\"\r\n                && fnTest.test(method)\r\n            )\r\n            ? function () {\r\n\r\n                var hasSuper = \"$super\" in this;\r\n                var temp = this.$super;\r\n                var returnValue = null;\r\n\r\n                this.$super = parent[name];\r\n                returnValue = method.apply(this, arguments);\r\n\r\n                if (hasSuper) {\r\n                    this.$super = temp;\r\n                } else {\r\n                    delete this.$super;\r\n                }\r\n\r\n                return returnValue;\r\n\r\n            }\r\n            : method\r\n        );\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Creates a Class.\r\n *\r\n * @see    https://johnresig.com/blog/simple-javascript-inheritance/\r\n * @param  {Class} [Base]\r\n *         Optional parent class.\r\n * @param  {Object} proto\r\n *         Methods to add to the created Class' prototype.\r\n * @return {Class}\r\n *         Class created.\r\n */\r\nARIA.createClass = function (Base, proto) {\r\n\r\n    function Class() {\r\n        return this.init.apply(this, arguments);\r\n    }\r\n\r\n    if (!proto) {\r\n\r\n        proto = Base;\r\n        Base = Object;\r\n\r\n    }\r\n\r\n    Class.addMethod = addClassMethods;\r\n\r\n    /**\r\n     * Alias of {@link Class.addMethod}\r\n     */\r\n    Class.addMethods = addClassMethods;\r\n\r\n    /**\r\n     * Reference to the prototype of the Class' super-class.\r\n     * @type {Object}\r\n     */\r\n    Class.parent = Base.prototype;\r\n\r\n    Class.prototype = Object.create(Base.prototype);\r\n    addClassMethods.call(Class, proto);\r\n\r\n    Class.prototype.constructor = Class;\r\n\r\n    if (typeof Class.prototype.init !== \"function\") {\r\n        Class.prototype.init = noop;\r\n    }\r\n\r\n    return Class;\r\n\r\n};\r\n\r\n/**\r\n * A wrapper for setting an attribute on an element. This allows the method to\r\n * be easily replaced for virtual DOMs.\r\n *\r\n * @param {Element} element\r\n *        Element whose attribute should be set.\r\n * @param {String} name\r\n *        Name of the attribute to set.\r\n * @param {String} value\r\n *        Value of the attribute.\r\n */\r\nARIA.setAttribute = function (element, name, value) {\r\n    element.setAttribute(name, value);\r\n};\r\n\r\n/**\r\n * A wrapper for getting an attribute of an element. This allows the method to\r\n * be easily replaced for virtual DOMs.\r\n *\r\n * @param  {Element} element\r\n *         Element whose attribute should be retrieved.\r\n * @param  {String} name\r\n *         Name of the attribute to retrieve.\r\n * @return {String|null}\r\n *         The value of the attribute or null if that attribute does not exist.\r\n */\r\nARIA.getAttribute = function (element, name) {\r\n    return element.getAttribute(name);\r\n};\r\n\r\n/**\r\n * A wrapper for checking for an attribute on an element. This allows the method\r\n * to be easily replaced for virtual DOMs.\r\n *\r\n * @param  {Element} element\r\n *         Element whose attribute should be checked.\r\n * @param  {String} name\r\n *         Name of the attribute to check.\r\n * @return {Boolean}\r\n *         true if the element has the given attribute, false otherwise.\r\n */\r\nARIA.hasAttribute = function (element, name) {\r\n    return element.hasAttribute(name);\r\n};\r\n\r\n/**\r\n * A wrapper for removing an attribute from an element. This allows the method\r\n * to be easily replaced for virtual DOMs.\r\n *\r\n * @param {Element} element\r\n *        Element whose attribute should be removed.\r\n * @param {String} name\r\n *        Name of the attribute to remove.\r\n */\r\nARIA.removeAttribute = function (element, name) {\r\n    element.removeAttribute(name);\r\n};\r\n\r\n/**\r\n * Gets an element by the given ID. If the element cannot be found, null is\r\n * returned. This function is just a wrapper for document.getElementById to\r\n * allow the library to be easily modified in case a virtual DOM is being used.\r\n *\r\n * @param  {String} id\r\n *         ID of the element to find.\r\n * @return {Element|null}\r\n *         Element with the given ID or null if the element cannot be found.\r\n */\r\nARIA.getById = function (id) {\r\n    return document.getElementById(id);\r\n};\r\n\r\nvar counter = 0;\r\n\r\n/**\r\n * The default prefix for {@link ARIA.identify}.\r\n * @type {String}\r\n */\r\nARIA.defaultIdentifyPrefix = \"anonymous-element-\";\r\n\r\n/**\r\n * Returns the ID of the given element. If the element does not have an ID, a\r\n * unique one is generated. The generated ID is the given prefix and an\r\n * incrementing counter.\r\n * Pro tip: The HTML specs state that element IDs should start with a letter.\r\n *\r\n * @param  {Element} element\r\n *         Element whose ID should be returned.\r\n * @param  {String} [prefix=ARIA.defaultIdentifyPrefix]\r\n *         Prefix for the generated ID.\r\n * @return {String}\r\n *         The ID of the element.\r\n * @see    http://api.prototypejs.org/dom/Element/identify/\r\n */\r\nARIA.identify = function (element, prefix) {\r\n\r\n    var id = ARIA.getAttribute(element, \"id\");\r\n\r\n    if (prefix === undefined) {\r\n        prefix = ARIA.defaultIdentifyPrefix;\r\n    }\r\n\r\n    if (!id) {\r\n\r\n        do {\r\n\r\n            id = prefix + counter;\r\n            counter += 1;\r\n\r\n        } while (ARIA.getById(id));\r\n\r\n        ARIA.setAttribute(element, \"id\", id);\r\n\r\n    }\r\n\r\n    return id;\r\n\r\n};\r\n\r\n/**\r\n * Checks to see if the given value is a Node.\r\n *\r\n * @param  {?} value\r\n *         Value to test.\r\n * @return {Boolean}\r\n *         true if the given value is a Node, false otherwise.\r\n */\r\nARIA.isNode = function (value) {\r\n    return (value instanceof Node);\r\n};\r\n\r\n/**\r\n * A map for keeping all dummy elements in {@link ARIA.Observer}.\r\n * @private\r\n * @type {WeakMap}\r\n */\r\nvar observerMap = new WeakMap();\r\n\r\n/**\r\n * Creates observers.\r\n *\r\n * @class ARIA.Observer\r\n */\r\nARIA.Observer = ARIA.createClass(/** @lends ARIA.Observer.prototype */{\r\n\r\n    /**\r\n     * Gets the element that will dispatch events for this observer.\r\n     *\r\n     * @return {Element}\r\n     *         Element that will dispatch events.\r\n     */\r\n    getEventElement: function () {\r\n\r\n        var dummy = observerMap.get(this);\r\n\r\n        if (!dummy) {\r\n\r\n            dummy = document.createElement(\"div\");\r\n            observerMap.set(this, dummy);\r\n\r\n        }\r\n\r\n        return dummy;\r\n\r\n    },\r\n\r\n    /**\r\n     * Creates a custom event.\r\n     *\r\n     * @param  {String} name\r\n     *         Name of the event to create.\r\n     * @param  {?} [detail]\r\n     *         Optional detail to be passed to the event.\r\n     * @return {CustomEvent}\r\n     *         Custom event.\r\n     */\r\n    createEvent: function (name, detail) {\r\n\r\n        return new CustomEvent(name, {\r\n            bubbles: true,\r\n            cancelable: true,\r\n            detail: detail\r\n        });\r\n\r\n    },\r\n\r\n    /**\r\n     * Dispatches the given event on the element that comes from\r\n     * {@link ARIA.Observer#getEventElement}. If the event parameter is a\r\n     * string, it is passed to {@link ARIA.Observer#createEvent}.\r\n     *\r\n     * @param  {Event|string} event\r\n     *         Either the event to dispatch or the name of the event to\r\n     *         dispatch.\r\n     * @param  {?} [detail]\r\n     *         Optional detail for the event. This is only used if the event\r\n     *         parameter is a string.\r\n     * @return {Event}\r\n     *         The event that was dispatched.\r\n     */\r\n    dispatchEvent: function (event, detail) {\r\n\r\n        if (typeof event === \"string\") {\r\n            event = this.createEvent(event, detail);\r\n        }\r\n\r\n        this.getEventElement().dispatchEvent(event);\r\n\r\n        return event;\r\n\r\n    },\r\n\r\n    /**\r\n     * Adds an event listener to the element that comes from\r\n     * {@link ARIA.Observer#getEventElement}.\r\n     *\r\n     * @param {String} name\r\n     *        Name of the event to which a listener should be added.\r\n     * @param {Function} handler\r\n     *        Function to execute when the event is dispatched.\r\n     */\r\n    addEventListener: function (name, handler) {\r\n        this.getEventElement().addEventListener(name, handler);\r\n    },\r\n\r\n    /**\r\n     * Removes an event listener from the element that comes from\r\n     * {@link ARIA.Observer#getEventElement}.\r\n     *\r\n     * @param {String} name\r\n     *        Name of the event from which a listener should be removed.\r\n     * @param {Function} handler\r\n     *        Function to remove from the event listener.\r\n     */\r\n    removeEventListener: function (name, handler) {\r\n        this.getEventElement().removeEventListener(name, handler);\r\n    }\r\n\r\n});\r\n\r\n// Create a fall-back for browsers that don't allow CustomEvent to be used as a\r\n// constructor.\r\ntry {\r\n\r\n    var event = new CustomEvent(\"my-custom-event\", {\r\n        bubbles: true,\r\n        cancelable: true,\r\n        detail: {}\r\n    });\r\n\r\n} catch (ignore) {\r\n\r\n    ARIA.Observer.prototype.createEvent = function (name, detail) {\r\n\r\n        var event = document.createEvent(\"CustomEvent\");\r\n\r\n        event.initCustomEvent(name, true, true, detail);\r\n\r\n        return event;\r\n\r\n    };\r\n\r\n}\r\n\r\n/**\r\n * Instance of {@link ARIA.Observer} that is used by {@link ARIA.trigger},\r\n * {@link ARIA.on} and {@link ARIA.off}.\r\n * @type {ARIA.Observer}\r\n */\r\nARIA.observer = new ARIA.Observer();\r\n\r\n/**\r\n * Dispatches an event with {@link ARIA.observer}.\r\n *\r\n * @param  {String} name\r\n *         Name of the event to dispatch.\r\n * @param  {?} [detail]\r\n *         Optional detail for the event.\r\n * @return {Event}\r\n *         Event that was dispatched.\r\n */\r\nARIA.trigger = function (name, detail) {\r\n    return ARIA.observer.dispatchEvent(name, detail);\r\n};\r\n\r\n/**\r\n * Adds a handler to the given event.\r\n *\r\n * @param {String} name\r\n *        Name of the event to listen for.\r\n * @param {Function} handler\r\n *        Handler to execute when the event is dispatched.\r\n */\r\nARIA.on = function (name, handler) {\r\n    ARIA.observer.addEventListener(name, handler);\r\n};\r\n\r\n/**\r\n * Revmoes a handler from the given event.\r\n *\r\n * @param {String} name\r\n *        Name of the event to stop listening to.\r\n * @param {Function} handler\r\n *        Handler to remove from the event.\r\n */\r\nARIA.off = function (name, handler) {\r\n    ARIA.observer.removeEventListener(name, handler);\r\n};\r\n\r\n/**\r\n * Handles basic WAI-ARIA properties.\r\n *\r\n * @class ARIA.Property\r\n */\r\nARIA.Property = ARIA.createClass(/** @lends ARIA.Property.prototype */{\r\n\r\n    /**\r\n     * @constructs ARIA.Property\r\n     * @param      {Element} element\r\n     *             Element whose attribute should be handled.\r\n     * @param      {String} attribute\r\n     *             Name of the attribute to handle.\r\n     */\r\n    init: function (element, attribute) {\r\n\r\n        /**\r\n         * Element whose attribute is being handled.\r\n         * @type {Element}\r\n         */\r\n        this.element = element;\r\n\r\n        /**\r\n         * Attribute being handled.\r\n         * @type {String}\r\n         */\r\n        this.attribute = attribute;\r\n\r\n        // Things like ARIA.List work with interpretted values rather than just\r\n        // the attribute value. If the attribute already exists, pass the value\r\n        // to the set method to allow for that. As a bonus, this can filter out\r\n        // invalid attribute values.\r\n        if (ARIA.hasAttribute(element, attribute)) {\r\n            this.set(ARIA.getAttribute(element, attribute));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Interprets the given value so it can be set.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {String}\r\n     *         String based on the value.\r\n     */\r\n    interpret: function (value) {\r\n        return ARIA.Property.interpret(value);\r\n    },\r\n\r\n    /**\r\n     * Helper function for dispatching an event using {@link ARIA.trigger} which\r\n     * automatically passes {@link ARIA.Property#element} and\r\n     * {@link ARIA.Property#attribute} to the event details.\r\n     *\r\n     * @param  {String} event\r\n     *         Name of the event to dispatch.\r\n     * @param  {Object} [detail]\r\n     *         Optional additional details.\r\n     * @return {Event}\r\n     *         Dispatched event.\r\n     */\r\n    trigger: function (event, detail) {\r\n\r\n        return ARIA.trigger(event, objectAssign({\r\n            element: this.element,\r\n            attribute: this.attribute\r\n        }, detail));\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the value of {@link ARIA.Property#attribute} and interprets it\r\n     * (see {@link ARIA.Property#interpret}). If {@link ARIA.Property#element}\r\n     * doesn't have {@link ARIA.Property#attribute} then null is returned.\r\n     *\r\n     * @return {String|null}\r\n     *         Interpretted value of {@link ARIA.Property#attribute} or null if\r\n     *         the attribute is not set.\r\n     */\r\n    // get: function () {\r\n    //\r\n    //     var element = this.element;\r\n    //     var attribute = this.attribute;\r\n    //\r\n    //     return (\r\n    //         ARIA.hasAttribute(element, attribute)\r\n    //         ? this.interpret(ARIA.getAttribute(element, attribute))\r\n    //         : null\r\n    //     );\r\n    //\r\n    // },\r\n\r\n    /**\r\n     * Gets the value of {@link ARIA.Property#attribute} from\r\n     * {@link ARIA.Property#element} and interprets it (see\r\n     * {@link ARIA.Property#interpret}) before returning it. If the element\r\n     * doesn't have the attribute, null is returned.\r\n     *\r\n     * @return {String|null}\r\n     *         Interpretted value of {@link ARIA.Property#attribute} or null if\r\n     *         the attribute is not set.\r\n     * @fires  ARIA.Property#preget\r\n     * @fires  ARIA.Property#postget\r\n     */\r\n    get: function () {\r\n\r\n        var preEvent = this.trigger(ARIA.EVENT_PRE_GET);\r\n        var element = this.element;\r\n        var attribute = this.attribute;\r\n        var value;\r\n\r\n        if (!preEvent.defaultPrevented) {\r\n\r\n            value = (\r\n                ARIA.hasAttribute(element, attribute)\r\n                ? this.interpret(ARIA.getAttribute(element, attribute))\r\n                : null\r\n            );\r\n            this.trigger(ARIA.EVENT_POST_GET, {\r\n                value: value\r\n            });\r\n\r\n        }\r\n\r\n        return value;\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets {@link ARIA.Property#attribute} to the given value, once\r\n     * interpretted (see {@link ARIA.Property#interpret}) and validated (see\r\n     * {@link ARIA.Property#isValidToken}). If the value is interpretted as an\r\n     * empty string, the attribute is removed.\r\n     *\r\n     * @param {?} value\r\n     *        Value to set.\r\n     */\r\n    // set: function (value) {\r\n    //\r\n    //     var element = this.element;\r\n    //     var attribute = this.attribute;\r\n    //     var interpretted = this.interpret(value);\r\n    //\r\n    //     if (interpretted === \"\") {\r\n    //         ARIA.removeAttribute(element, attribute);\r\n    //     } else {\r\n    //         ARIA.setAttribute(element, attribute, interpretted);\r\n    //     }\r\n    //\r\n    // },\r\n\r\n    /**\r\n     * Sets the value of {@link ARIA.Property#attribute} on\r\n     * {@link ARIA.Property#element} to the given value once it's been\r\n     * interpretted (see {@link ARIA.Property#interpret}). If the value is\r\n     * interpretted as an empty string, the attribute is removed using\r\n     * {@link ARIA.Property#remove}.\r\n     *\r\n     * @param {?} value\r\n     *        Value to set.\r\n     * @fires ARIA.Property#preset\r\n     * @fires ARIA.Property#postset\r\n     */\r\n    set: function (value) {\r\n\r\n        var interpretted = this.interpret(value);\r\n        var eventData = {\r\n            raw: value,\r\n            value: interpretted\r\n        };\r\n        var preEvent = this.trigger(ARIA.EVENT_PRE_SET, eventData);\r\n\r\n        if (!preEvent.defaultPrevented) {\r\n\r\n            if (interpretted === \"\") {\r\n                this.remove();\r\n            } else {\r\n                ARIA.setAttribute(this.element, this.attribute, interpretted);\r\n            }\r\n\r\n            this.trigger(ARIA.EVENT_POST_SET, eventData);\r\n\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Removes {@link ARIA.Property#attribute} from\r\n     * {@link ARIA.Property#element}.\r\n     *\r\n     * @fires ARIA.Property#preremove\r\n     * @fires ARIA.Property#postremove\r\n     */\r\n    remove: function () {\r\n\r\n        var preEvent = this.trigger(ARIA.EVENT_PRE_REMOVE);\r\n\r\n        if (!preEvent.defaultPrevented) {\r\n\r\n            ARIA.removeAttribute(this.element, this.attribute);\r\n            this.trigger(ARIA.EVENT_POST_REMOVE);\r\n\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of {@link ARIA.Property#attribute} as a string. See\r\n     * {@link ARIA.Property#get}.\r\n     *\r\n     * @return {String}\r\n     *         Value of the attribute.\r\n     */\r\n    toString: function () {\r\n        return ARIA.getAttribute(this.element, this.attribute) || \"\";\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Interprets the given value so it can be set. This is used to power\r\n * {@link ARIA.Property#interpret} while also being exposed so other functions\r\n * and classes can use it.\r\n *\r\n * @param  {?} value\r\n *         Value to interpret.\r\n * @return {String}\r\n *         String based on the value.\r\n */\r\nARIA.Property.interpret = interpretString;\r\n\r\n/**\r\n * Name of the {@link ARIA.Property#preset} event.\r\n * @type {String}\r\n */\r\nARIA.EVENT_PRE_SET = \"ariajs-pre-set\";\r\n/**\r\n * Event triggered before setting a WAI-ARIA property with\r\n * {@link ARIA.Property#set}. If the default action of this event is prevented,\r\n * the value is not set.\r\n *\r\n * @event    ARIA.Property#preset\r\n * @type     {Event}\r\n * @property {Object} detail\r\n *           Event details.\r\n * @property {Element} detail.element\r\n *           Element that will have the attribute value set.\r\n * @property {String} detail.attribute\r\n *           Name of the attribute that will be set.\r\n * @property {String} detail.raw\r\n *           Raw value for to set on the value.\r\n * @property {Array<Element>|Array<String>|Element|Number|String} detail.value\r\n *           Version of the value after it has been passed through\r\n *           {@link ARIA.Property#interpret}. This is the value that will be set\r\n *           on the attribute.\r\n */\r\n\r\n/**\r\n * Name of the {@link ARIA.Property#postset} event.\r\n * @type {String}\r\n */\r\nARIA.EVENT_POST_SET = \"ariajs-post-set\";\r\n/**\r\n * Event triggered after setting a WAI-ARIA property with\r\n * {@link ARIA.Property#set}.\r\n *\r\n * @event    ARIA.Property#postset\r\n * @type     {Event}\r\n * @property {Object} detail\r\n *           Event details.\r\n * @property {Element} detail.element\r\n *           Element that had the attribute value set.\r\n * @property {String} detail.attribute\r\n *           Name of the attribute that was set.\r\n * @property {String} detail.raw\r\n *           Raw value of the attribute.\r\n * @property {Array<Element>|Array<String>|Element|Number|String} detail.value\r\n *           Version of the value after it has been passed through\r\n *           {@link ARIA.Property#interpret}.\r\n */\r\n\r\n/**\r\n * Name of the {@link ARIA.Property#preget} event.\r\n * @type {String}\r\n */\r\nARIA.EVENT_PRE_GET = \"ariajs-pre-get\";\r\n/**\r\n * Event triggered before getting a WAI-ARIA property with\r\n * {@link ARIA.Property#get}. If the default action of this event is prevented,\r\n * the value is not retrieved.\r\n *\r\n * @event    ARIA.Property#preget\r\n * @type     {Event}\r\n * @property {Object} detail\r\n *           Event details.\r\n * @property {Element} detail.element\r\n *           Element whose attribute value should be retrieved.\r\n * @property {String} detail.attribute\r\n *           Name of the attribute whose value should be retrieved.\r\n */\r\n\r\n/**\r\n * Name of the {@link ARIA.Property#postget} event.\r\n * @type {String}\r\n */\r\nARIA.EVENT_POST_GET = \"ariajs-post-get\";\r\n/**\r\n * Event triggered before getting a WAI-ARIA property with\r\n * {@link ARIA.Property#get}.\r\n *\r\n * @event    ARIA.Property#postget\r\n * @type     {Event}\r\n * @property {Object} detail\r\n *           Event details.\r\n * @property {Element} detail.element\r\n *           Element whose attribute value should be retrieved.\r\n * @property {String} detail.attribute\r\n *           Name of the attribute whose value should be retrieved.\r\n * @property {?} detail.value\r\n *           The value of the attribute after being passed through\r\n *           {@link ARIA.Property#interpret}. If the element does not have the\r\n *           attribute, this value will be null.\r\n */\r\n\r\n/**\r\n * Name of the {@link ARIA.Property#preremove} event.\r\n * @type {String}\r\n */\r\nARIA.EVENT_PRE_REMOVE = \"ariajs-pre-remove\";\r\n/**\r\n * Event triggered before removing a WAI-ARIA attribute using\r\n * {@link ARIA.Property#remove}. If the default is prevented, the attribute is\r\n * not removed.\r\n *\r\n * @event    ARIA.Property#preremove\r\n * @type     {Event}\r\n * @property {Object} detail\r\n *           Event details.\r\n * @property {Element} detail.element\r\n *           Element whose attribute should be removed.\r\n * @property {String} detail.attribute\r\n *           Name of the attribute to remove.\r\n */\r\n\r\n/**\r\n * Name of the {@link ARIA.Property#postremove} event.\r\n * @type {String}\r\n */\r\nARIA.EVENT_POST_REMOVE = \"ariajs-post-remove\";\r\n/**\r\n * Event triggered after removing a WAI-ARIA attribute using\r\n * {@link ARIA.Property#remove}.\r\n *\r\n * @event    ARIA.Property#postremove\r\n * @type     {Event}\r\n * @property {Object} detail\r\n *           Event details.\r\n * @property {Element} detail.element\r\n *           Element whose attribute should be removed.\r\n * @property {String} detail.attribute\r\n *           Name of the attribute to remove.\r\n */\r\n\r\n/**\r\n * Handles number values.\r\n *\r\n * @class ARIA.Integer\r\n * @extends ARIA.Property\r\n */\r\nARIA.Number = ARIA.createClass(ARIA.Property, /** @lends ARIA.Number.prototype */{\r\n\r\n    /**\r\n     * Interprets the value as a number. If the value can't be converted into a\r\n     * number, NaN is returned.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Number}\r\n     *         Number value.\r\n     */\r\n    interpret: function (value) {\r\n        return parseFloat(this.$super(value));\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles number values.\r\n *\r\n * @class ARIA.Integer\r\n * @extends ARIA.Number\r\n */\r\nARIA.Integer = ARIA.createClass(ARIA.Number, /** @lends ARIA.Integer.prototype */{\r\n\r\n    /**\r\n     * Interprets the value as an integer. If the value can't be converted into\r\n     * a number, NaN is returned.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Number}\r\n     *         Number value.\r\n     */\r\n    interpret: function (value) {\r\n        return Math.floor(this.$super(value));\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles WAI-ARIA states.\r\n *\r\n * @class ARIA.State\r\n * @extends ARIA.Property\r\n */\r\nARIA.State = ARIA.createClass(ARIA.Property, /** @lends ARIA.State.prototype */{\r\n\r\n    /**\r\n     * Coerces the given value into a boolean.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to coerce.\r\n     * @return {Boolean|String}\r\n     *         Coerced boolean or an empty string.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        var interpretted = this.$super(value);\r\n        var isTrue = interpretted === \"true\";\r\n\r\n        return (\r\n            (isTrue || interpretted === \"false\")\r\n            ? isTrue\r\n            : interpretted\r\n        );\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles a WAI-ARIA state that can be true or false but can also be undefined.\r\n *\r\n * @class ARIA.UndefinedState\r\n * @extends ARIA.State\r\n */\r\nARIA.UndefinedState = ARIA.createClass(ARIA.State, /** @lends ARIA.UndefinedState.prototype */{\r\n\r\n    /**\r\n     * Interprets undefined as \"undefined.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Boolean|String}\r\n     *         Either the boolean value, \"undefined\" or an empty string if the\r\n     *         value is not understood.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        return (\r\n            (value === undefined || value === \"undefined\")\r\n            ? \"undefined\"\r\n            : this.$super(value)\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean or undefined.\r\n     *\r\n     * @return {Boolean|undefined}\r\n     *         Value of the attribute.\r\n     */\r\n    get: function () {\r\n\r\n        var value = this.$super();\r\n\r\n        if (value === \"undefined\") {\r\n            value = undefined;\r\n        }\r\n\r\n        return value;\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles WAI-ARIA tristates. That is, a state that can be either true, false\r\n * or \"mixed\".\r\n *\r\n * @class ARIA.Tristate\r\n * @extends ARIA.State\r\n */\r\nARIA.Tristate = ARIA.createClass(ARIA.State, /** @lends ARIA.Tristate.prototype */{\r\n\r\n    /**\r\n     * Allows the token \"mixed\".\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Boolean|String}\r\n     *         Either the boolean value, \"mixed\" or an empty string if the value\r\n     *         is not understood.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        return (\r\n            value === \"mixed\"\r\n            ? value\r\n            : this.$super(value)\r\n        );\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles a WAI-ARIA attribute that should be a space-separated list.\r\n *\r\n * @class ARIA.List\r\n * @extends ARIA.Property\r\n */\r\nARIA.List = ARIA.createClass(ARIA.Property, /** ARIA.List.prototype */{\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    init: function (element, attribute) {\r\n\r\n        /**\r\n         * The list of values.\r\n         * @type {Array.<String>}\r\n         */\r\n        this.list = [];\r\n\r\n        this.$super(element, attribute);\r\n\r\n    },\r\n\r\n    /**\r\n     * Coerces the values into a string and splits it at the spaces.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {Array.<String>}\r\n     *         Array of strings.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        var val = (\r\n            Array.isArray(value)\r\n            ? value.join(\" \")\r\n            : value\r\n        );\r\n        var string = this.$super(val);\r\n\r\n        return (\r\n            string.length\r\n            ? string.split(/\\s+/)\r\n            : []\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the value of the list to be the given value. The values are\r\n     * interpretted as an array (see {@link ARIA.List#interpret} and validated\r\n     * (see {@link ARIA.List#isValidToken}); only unique values are added.\r\n     *\r\n     * @param {?} value\r\n     *        Value(s) to add. If the given value is a string, it is assumed to\r\n     *        be a space-separated list.\r\n     */\r\n    // set: function (value) {\r\n    //\r\n    //     var that = this;\r\n    //     var values = that.interpret(value).reduce(function (unique, token) {\r\n    //\r\n    //         if (token && unique.indexOf(token) < 0) {\r\n    //             unique.push(token);\r\n    //         }\r\n    //\r\n    //         return unique;\r\n    //\r\n    //     }, []);\r\n    //     var element = that.element;\r\n    //     var attribute = that.attribute;\r\n    //\r\n    //     that.list = values;\r\n    //\r\n    //     if (values.length) {\r\n    //         ARIA.setAttribute(element, attribute, values.join(\" \"));\r\n    //     } else {\r\n    //         ARIA.removeAttribute(element, attribute);\r\n    //     }\r\n    //\r\n    // },\r\n\r\n    /**\r\n     * Sets the value of the list to be the given value. The values are\r\n     * interpretted as an array (see {@link ARIA.List#interpret}). If the values\r\n     * are interpretted as empty array, the attribute is removed using\r\n     * {@link ARIA.Property#remove}. Only unique values are added (see\r\n     * {@link ARIA.arrayUnique}).\r\n     *\r\n     * @param {?} value\r\n     *        Value(s) to add. If the given value is a string, it is assumed to\r\n     *        be a space-separated list.\r\n     * @fires ARIA.Property#preset\r\n     * @fires ARIA.Property#postset\r\n     */\r\n    set: function (value) {\r\n\r\n        var that = this;\r\n        var values = arrayUnique(that.interpret(value));\r\n        var eventData = {\r\n            raw: value,\r\n            value: values\r\n        };\r\n        var preEvent = this.trigger(ARIA.EVENT_PRE_SET, eventData);\r\n\r\n        if (!preEvent.defaultPrevented) {\r\n\r\n            that.list = values;\r\n\r\n            if (values.length) {\r\n\r\n                ARIA.setAttribute(\r\n                    this.element,\r\n                    this.attribute,\r\n                    values.join(\" \")\r\n                );\r\n\r\n            } else {\r\n                this.remove();\r\n            }\r\n\r\n            this.trigger(ARIA.EVENT_POST_SET, eventData);\r\n\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the value of the attribute as an array.\r\n     *\r\n     * @return {Array.<String>}\r\n     *         Value of the attribute as an array.\r\n     */\r\n    // get: function () {\r\n    //     return this.list.concat();\r\n    // }\r\n\r\n    /**\r\n     * Gets the value of {@link ARIA.Property#attribute} as an array. Modifying\r\n     * the array will not affect the attribute.\r\n     *\r\n     * @param  {Function} [map]\r\n     *         Optional mapping function for converting the results.\r\n     * @return {Array.<String>}\r\n     *         Value of the attribute as an array.\r\n     * @fires  ARIA.Property#preget\r\n     * @fires  ARIA.Property#postget\r\n     */\r\n    get: function (map) {\r\n\r\n        var preEvent = this.trigger(ARIA.EVENT_PRE_GET);\r\n        var list = [];\r\n\r\n        if (!preEvent.defaultPrevented) {\r\n\r\n            list = arrayFrom(this.list, map);\r\n            this.trigger(ARIA.EVENT_POST_GET, {\r\n                value: list\r\n            });\r\n\r\n        }\r\n\r\n        return list;\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles WAI-ARIA attributes that reference a single ID.\r\n *\r\n * @class ARIA.Reference\r\n * @extends ARIA.Property\r\n */\r\nARIA.Reference = ARIA.createClass(ARIA.Property, /** @lends ARIA.Reference.prototype */{\r\n\r\n    /**\r\n     * Interprets the given value as a string. If the value is an element, the\r\n     * element's ID is returned, generating one if necessary - see\r\n     * {@link ARIA.identify}.\r\n     *\r\n     * @param  {?} value\r\n     *         Value to interpret.\r\n     * @return {String}\r\n     *         The interpretted value.\r\n     */\r\n    interpret: function (value) {\r\n        return ARIA.Reference.interpret(value);\r\n    },\r\n\r\n    /**\r\n     * Gets the element referenced by this attribute. If the element cannot be\r\n     * found or the attribute isn't set, null is returned.\r\n     *\r\n     * @return {Element|null}\r\n     *         Element referenced by this attribute or null if the element\r\n     *         cannot be found or the attribute isn't set.\r\n     */\r\n    get: function () {\r\n        return ARIA.getById(this.$super());\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Interprets the given value as a string. If the value is an element, the\r\n * element's ID is returned, generating one if necessary = see\r\n * {@link ARIA.identify}. This powers {@link ARIA.Reference#interpret} while\r\n * also allowing other functions and classes to use it.\r\n *\r\n * @param  {?} value\r\n *         Value to interpret.\r\n * @return {String}\r\n *         The interpretted value.\r\n */\r\nARIA.Reference.interpret = function (value) {\r\n\r\n    return (\r\n        ARIA.isNode(value)\r\n        ? ARIA.identify(value)\r\n        : ARIA.Property.interpret(value)\r\n    );\r\n\r\n};\r\n\r\n/**\r\n * Handles WAI-ARIA attributes that handle space-separated lists of IDs.\r\n * @class ARIA.ReferenceList\r\n * @extends ARIA.List\r\n */\r\nARIA.ReferenceList = ARIA.createClass(ARIA.List, /** @lends ARIA.ReferenceList.prototype */{\r\n\r\n    /**\r\n     * Interprets an element, ID or array of elements or/and IDs as an array of\r\n     * element IDs.\r\n     *\r\n     * @param  {Array.<Element|String>|Element|String} value\r\n     *         Value(s) to interpret.\r\n     * @return {Array.<String>}\r\n     *         Collection of IDs.\r\n     */\r\n    interpret: function (value) {\r\n\r\n        var interpretted = [];\r\n\r\n        if (\r\n            value\r\n            && typeof value === \"object\"\r\n            && typeof value.length === \"number\"\r\n        ) {\r\n            interpretted = arrayFrom(value, ARIA.Reference.interpret, this);\r\n        } else if (typeof value === \"string\") {\r\n            interpretted = this.$super(value);\r\n        } else {\r\n            interpretted = [ARIA.Reference.interpret(value)];\r\n        }\r\n\r\n        // Remove all falsy values such as \"\" or null.\r\n        return interpretted.filter(Boolean);\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets an array of elements referenced by the attribute. If the element\r\n     * cannot be found, null will be in place of the element.\r\n     *\r\n     * @return {Array.<Element|null>}\r\n     *         Array of elements.\r\n     */\r\n    get: function () {\r\n        return this.$super(ARIA.getById);\r\n        // return this.$super().map(ARIA.getById);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Handles the WAI-ARIA attributes on an element.\r\n *\r\n * @class ARIA.Element\r\n */\r\nARIA.Element = ARIA.createClass(/** @lends ARIA.ELement.prototype */{\r\n\r\n    /**\r\n     * @constructs ARIA.Element\r\n     * @param      {Element} element\r\n     *             Element whose WAI-ARIA attributes should be handled.\r\n     */\r\n    init: function (element) {\r\n\r\n        /**\r\n         * Element whose WAI-ARIA attributes should be handled.\r\n         * @type {Element}\r\n         */\r\n        this.element = element;\r\n\r\n        /**\r\n         * Instances of {@link ARIA.Property} (or sub-classes) that are used to\r\n         * check get and set values.\r\n         * @type {Object}\r\n         */\r\n        this.instances = Object.create(null);\r\n\r\n        this.readAttributes();\r\n        this.observeAttributes();\r\n\r\n        return this.activateTraps();\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the instance from {@link ARIA.Element#instances} for the given\r\n     * attribute. If the instance does not exist but a factory exists, the\r\n     * instance is created and stored before being returned.\r\n     *\r\n     * @param  {String} attribute\r\n     *         Attribute whose instance should be found.\r\n     * @return {ARIA.Property}\r\n     *         Instance of {@link ARIA.Property} (or sub-class).\r\n     */\r\n    getInstance: function (attribute) {\r\n\r\n        var instance = this.instances[attribute];\r\n\r\n        if (!instance && ARIA.getFactory(attribute)) {\r\n\r\n            instance = ARIA.runFactory(attribute, this.element);\r\n            this.instances[attribute] = instance;\r\n\r\n        }\r\n\r\n        return instance;\r\n\r\n    },\r\n\r\n    /**\r\n     * Reads all the WAI-ARIA attributes on {@link ARIA.Element#element} and\r\n     * sets the {@link ARIA.Property} values.\r\n     */\r\n    readAttributes: function () {\r\n\r\n        arrayFrom(this.element.attributes, function (attribute) {\r\n\r\n            var value = attribute.value;\r\n            var instance = (\r\n                value\r\n                ? this.getInstance(attribute.name)\r\n                : undefined\r\n            );\r\n\r\n            if (instance) {\r\n                instance.set(value);\r\n            }\r\n\r\n        }, this);\r\n\r\n    },\r\n\r\n    /**\r\n     * Creates the observer {@link ARIA.Element#observer} that listens for\r\n     * changes to WAI-ARIA attribtues and updates the {@link ARIA.Property}\r\n     * values.\r\n     */\r\n    observeAttributes: function () {\r\n\r\n        var that = this;\r\n\r\n        /**\r\n         * The observer.\r\n         * @type {MutationObserver}\r\n         */\r\n        that.observer = ARIA.Element.makeObserver(\r\n            that.element,\r\n            function (data) {\r\n                return Boolean(ARIA.factories[data.suffix]);\r\n            },\r\n            function (data) {\r\n                that[data.suffix] = data.value;\r\n            },\r\n            function (data) {\r\n                that[data.suffix] = \"\";\r\n            }\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Disconnects {@link ARIA.Element#observer}.\r\n     */\r\n    disconnectAttributes: function () {\r\n        this.observer.disconnect();\r\n    },\r\n\r\n    /**\r\n     * Activates the get, set and delete traps for the instance which enables\r\n     * the interface.\r\n     *\r\n     * @return {Proxy}\r\n     *         Proxy of the instance (if the browser supports it).\r\n     */\r\n    activateTraps: function () {\r\n\r\n        return new Proxy(this, {\r\n\r\n            get: function (target, name) {\r\n\r\n                var value = target[name];\r\n                var instance = target.getInstance(name);\r\n\r\n                if (instance) {\r\n                    value = instance.get();\r\n                }\r\n\r\n                return value;\r\n\r\n            },\r\n\r\n            set: function (target, name, value) {\r\n\r\n                var instance = target.getInstance(name);\r\n\r\n                if (instance) {\r\n                    instance.set(value);\r\n                } else {\r\n                    target[name] = value;\r\n                }\r\n\r\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set#Return_value\r\n                return true;\r\n\r\n            },\r\n\r\n            deleteProperty: function (target, name) {\r\n\r\n                var instance = target.getInstance(name);\r\n\r\n                if (instance) {\r\n                    instance.set(\"\");\r\n                } else {\r\n                    delete target[name];\r\n                }\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Creates an observer to listen for attribute changes.\r\n *\r\n * @param  {Element} element\r\n *         Element whose attribute changes should be observed.\r\n * @param  {Function} checker\r\n *         Function to execute when checking whether the attribute change should\r\n *         be observed. Accepts an object with \"attribute\" and \"suffix\"\r\n *         properties, returns a boolean.\r\n * @param  {Function} setter\r\n *         Function to execute when an attribute change has been detected.\r\n *         Accepts an object and \"attribute\", \"suffix\", \"value\" and \"old\"\r\n *         properties.\r\n * @param  {Function} unsetter\r\n *         Function to execute when an attribute has been removed. Accepts an\r\n *         object with \"attribute\" and \"suffix\" properties.\r\n * @return {MutationObserver}\r\n *         MutationObserver that observes the attribute changes.\r\n */\r\nARIA.Element.makeObserver = function (element, checker, setter, unsetter) {\r\n\r\n    var manipulationFlags = Object.create(null);\r\n    var observer = new MutationObserver(function (mutations) {\r\n\r\n        mutations.forEach(function (mutation) {\r\n\r\n            var attribute = mutation.attributeName || \"\";\r\n            var suffix = ARIA.removePrefix(attribute);\r\n            var data = {\r\n                attribute: attribute,\r\n                suffix: suffix\r\n            };\r\n\r\n            if (\r\n                mutation.type === \"attributes\"\r\n                && !manipulationFlags[suffix]\r\n                && checker(data)\r\n            ) {\r\n\r\n                manipulationFlags[suffix] = true;\r\n\r\n                if (ARIA.hasAttribute(element, attribute)) {\r\n\r\n                    data.value = ARIA.Property.interpret(\r\n                        ARIA.getAttribute(element, attribute)\r\n                    );\r\n                    data.old = ARIA.Property.interpret(mutation.oldValue);\r\n                    setter(data);\r\n\r\n                } else {\r\n                    unsetter(data);\r\n                }\r\n\r\n                requestAnimationFrame(function () {\r\n                    delete manipulationFlags[suffix];\r\n                });\r\n\r\n            }\r\n\r\n        });\r\n\r\n    });\r\n\r\n    observer.observe(element, {\r\n        attributes: true,\r\n        attributeOldValue: true\r\n    });\r\n\r\n    return observer;\r\n\r\n};\r\n\r\n// Create a fall-back for browsers that don't understand Proxy.\r\n// Object.defineProperty can be used for get and set, but delete will have to\r\n// rely on polling.\r\nif (!globalVariable.Proxy) {\r\n\r\n    ARIA.Element.prototype.activateTraps = function () {\r\n\r\n        var that = this;\r\n\r\n        Object.keys(ARIA.factories).forEach(function setProperty(attribute) {\r\n\r\n            var isPolling = false;\r\n\r\n            Object.defineProperty(that, attribute, {\r\n\r\n                configurable: true,\r\n\r\n                get: function () {\r\n                    return that.getInstance(attribute).get();\r\n                },\r\n\r\n                set: function (value) {\r\n\r\n                    var instance = that.getInstance(attribute);\r\n\r\n                    if (value === \"\") {\r\n                        isPolling = false;\r\n                    } else if (value !== \"\" && !isPolling) {\r\n\r\n                        requestAnimationFrame(function poll() {\r\n\r\n                            if (isPolling) {\r\n\r\n                                if (owns(that, attribute)) {\r\n\r\n                                    requestAnimationFrame(poll);\r\n                                    isPolling = true;\r\n\r\n                                } else {\r\n\r\n                                    isPolling = false;\r\n                                    instance.set(\"\");\r\n                                    setProperty(attribute);\r\n\r\n                                }\r\n\r\n                            }\r\n\r\n                        });\r\n                        isPolling = true;\r\n\r\n                    }\r\n\r\n                    return instance.set(value);\r\n\r\n                }\r\n\r\n            });\r\n\r\n        });\r\n\r\n    };\r\n\r\n}\r\n\r\n/**\r\n * Collection of factories for creating WAI-ARIA libraries. The attribute key\r\n * should be the attribute suffixes (e.g. \"label\" for \"aria-label\" etc.)\r\n * @type {Object}\r\n */\r\nARIA.factories = Object.create(null);\r\n\r\n/**\r\n * Gets the factory from {@link ARIA.factories} that matches either the given\r\n * attribute or the normalised version (see {@link ARIA.normalise}).\r\n *\r\n * @param  {String} attribute\r\n *         Attribute whose factory should be returned.\r\n * @return {Function}\r\n *         Factory for creating the attribute.\r\n */\r\nARIA.getFactory = function (attribute) {\r\n\r\n    return (\r\n        ARIA.factories[attribute]\r\n        || ARIA.factories[ARIA.removePrefix(attribute)]\r\n    );\r\n\r\n};\r\n\r\n/**\r\n * Executes the factory for the given attribute, passing in given parameters.\r\n * See {@link ARIA.getFactory}.\r\n *\r\n * @param  {String} attribute\r\n *         Attribute whose factory should be executed.\r\n * @param  {Element} element\r\n *         Element that should be passed to the factory.\r\n * @return {ARIA.Property}\r\n *         Instance of {@link ARIA.Property} (or sub-class) created by the\r\n *         factory.\r\n * @throws {ReferenceError}\r\n *         There must be a factory for the given attribute.\r\n */\r\nARIA.runFactory = function (attribute, element) {\r\n\r\n    var factory = ARIA.getFactory(attribute);\r\n\r\n    if (!factory) {\r\n        throw new ReferenceError(attribute + \" is not a recognised factory\");\r\n    }\r\n\r\n    return factory(element);\r\n\r\n};\r\n\r\n/**\r\n * Creates a factory that creates an aria property.\r\n *\r\n * @param  {String} attribute\r\n *         Normalised name of the attribute whose factory is created.\r\n * @param  {Function} Constructor\r\n *         Constructor for {@link ARIA.Property} (or sub-class) that will create\r\n *         the property.\r\n * @return {Function}\r\n *         A factory function that takes the element and returns the instance.\r\n */\r\nARIA.makeFactory = function (attribute, Constructor) {\r\n\r\n    return function (element) {\r\n        return new Constructor(element, attribute);\r\n    };\r\n\r\n};\r\n\r\n/**\r\n * All the factory entries that create the {@link ARIA.factories}. Each entry is\r\n * an array of two values: the {@link ARIA.Property} (or sub-class) constructor\r\n * and an array of the WAI-ARIA attribute suffixes (see {@link ARIA.removePrefix}).\r\n * @type {Array.<Array>}\r\n */\r\nARIA.factoryEntries = [\r\n    [ARIA.Property, [\r\n        \"autocomplete\",\r\n        \"current\",\r\n        \"haspopup\",\r\n        \"invalid\",\r\n        \"keyshortcuts\",\r\n        \"label\",\r\n        \"live\",\r\n        \"orientation\",\r\n        \"placeholder\",\r\n        \"roledescription\",\r\n        \"sort\",\r\n        \"valuetext\"\r\n    ]],\r\n    [ARIA.Reference, [\r\n        \"activedescendant\",\r\n        \"details\",\r\n        \"errormessage\"\r\n    ]],\r\n    [ARIA.ReferenceList, [\r\n        \"controls\",\r\n        \"describedby\",\r\n        \"flowto\",\r\n        \"labelledby\",\r\n        \"owns\"\r\n    ]],\r\n    [ARIA.State, [\r\n        \"atomic\",\r\n        \"busy\",\r\n        \"disabled\",\r\n        \"modal\",\r\n        \"multiline\",\r\n        \"multiselectable\",\r\n        \"readonly\",\r\n        \"required\"\r\n    ]],\r\n    [ARIA.Tristate, [\r\n        \"checked\",\r\n        \"pressed\"\r\n    ]],\r\n    [ARIA.UndefinedState, [\r\n        \"expanded\",\r\n        \"grabbed\",\r\n        \"hidden\",\r\n        \"selected\"\r\n    ]],\r\n    [ARIA.Integer, [\r\n        \"colcount\",\r\n        \"colindex\",\r\n        \"colspan\",\r\n        \"level\",\r\n        \"posinset\",\r\n        \"rowcount\",\r\n        \"rowindex\",\r\n        \"rowspan\",\r\n        \"setsize\"\r\n    ]],\r\n    [ARIA.Number, [\r\n        \"valuemax\",\r\n        \"valuemin\",\r\n        \"valuenow\"\r\n    ]],\r\n    [ARIA.List, [\r\n        \"dropeffect\",\r\n        \"relevant\",\r\n        \"role\"\r\n    ]]\r\n];\r\n\r\n/**\r\n * Creates the {@link ARIA.factories} based on {@link ARIA.factoryEntries}. As a\r\n * public function, this can be re-called if a plugin modifies\r\n * {@link ARIA.makeFactory}.\r\n */\r\nARIA.createFactories = function () {\r\n\r\n    ARIA.factoryEntries.forEach(function (entry) {\r\n\r\n        entry[1].forEach(function (attribute) {\r\n\r\n            ARIA.factories[attribute] = ARIA.makeFactory(\r\n                ARIA.addPrefix(attribute),\r\n                entry[0]\r\n            );\r\n\r\n        });\r\n\r\n    });\r\n\r\n};\r\n\r\n// Make initial factories.\r\nARIA.createFactories();\r\n\r\n/**\r\n * Creates an alias of WAI-ARIA attributes.\r\n *\r\n * @param  {String} source\r\n *         Source attribute for the alias.\r\n * @param  {Array.<String>|String} aliases\r\n *         Either a single alias or an array of aliases.\r\n * @throws {ReferenceError}\r\n *         The source attribute must have a related factory.\r\n */\r\nARIA.addAlias = function (source, aliases) {\r\n\r\n    var suffix = ARIA.removePrefix(source);\r\n\r\n    if (!Array.isArray(aliases)) {\r\n        aliases = [aliases];\r\n    }\r\n\r\n    if (!ARIA.getFactory(suffix)) {\r\n\r\n        throw new ReferenceError(\r\n            \"ARIA.factories.\"\r\n            + suffix\r\n            + \" does not exist\"\r\n        );\r\n\r\n    }\r\n\r\n    aliases.forEach(function (alias) {\r\n\r\n        var normalAlias = ARIA.removePrefix(alias);\r\n\r\n        ARIA.translate[normalAlias] = suffix;\r\n        ARIA.factories[normalAlias] = ARIA.factories[suffix];\r\n\r\n    });\r\n\r\n};\r\n\r\nARIA.addAlias(\"labelledby\", \"labeledby\");\r\n}(window));"],"file":"aria.min.js"}